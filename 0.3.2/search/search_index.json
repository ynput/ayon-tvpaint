{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"AYON TVPaint","text":"<p>TVPaint integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_tvpaint<ul> <li>addon</li> <li>api<ul> <li>communication_server</li> <li>launch_script</li> <li>lib</li> <li>pipeline</li> <li>plugin</li> </ul> </li> <li>hooks<ul> <li>pre_launch_args</li> </ul> </li> <li>lib</li> <li>plugins<ul> <li>create<ul> <li>convert_legacy</li> <li>create_render</li> <li>create_review</li> <li>create_workfile</li> </ul> </li> <li>load<ul> <li>load_image</li> <li>load_reference_image</li> <li>load_sound</li> <li>load_workfile</li> </ul> </li> <li>publish<ul> <li>collect_instance_frames</li> <li>collect_render_instances</li> <li>collect_workfile</li> <li>collect_workfile_data</li> <li>extract_convert_to_exr</li> <li>extract_sequence</li> <li>increment_workfile_version</li> <li>validate_asset_name</li> <li>validate_duplicated_layer_names</li> <li>validate_layers_visibility</li> <li>validate_marks</li> <li>validate_missing_layer_names</li> <li>validate_render_layer_group</li> <li>validate_render_pass_group</li> <li>validate_scene_settings</li> <li>validate_start_frame</li> <li>validate_workfile_metadata</li> <li>validate_workfile_project_name</li> </ul> </li> </ul> </li> <li>tvpaint_plugin</li> <li>version</li> <li>worker<ul> <li>worker</li> <li>worker_job</li> </ul> </li> </ul> </li> </ul> </li> <li>server<ul> <li>settings<ul> <li>create_plugins</li> <li>filters</li> <li>imageio</li> <li>main</li> <li>publish_plugins</li> <li>workfile_builder</li> </ul> </li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_tvpaint/index.html","title":"ayon_tvpaint","text":""},{"location":"autoapi/client/ayon_tvpaint/index.html#client.ayon_tvpaint.TVPaintAddon","title":"<code>TVPaintAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_tvpaint/addon.py</code> <pre><code>class TVPaintAddon(AYONAddon, IHostAddon):\n    name = \"tvpaint\"\n    version = __version__\n    host_name = \"tvpaint\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\"\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(TVPAINT_ROOT_DIR, \"hooks\")\n        ]\n\n    def get_workfile_extensions(self):\n        return [\".tvpp\"]\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/index.html#client.ayon_tvpaint.TVPaintAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_tvpaint/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\"\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_tvpaint/addon.html#client.ayon_tvpaint.addon.TVPaintAddon","title":"<code>TVPaintAddon</code>","text":"<p>               Bases: <code>AYONAddon</code>, <code>IHostAddon</code></p> Source code in <code>client/ayon_tvpaint/addon.py</code> <pre><code>class TVPaintAddon(AYONAddon, IHostAddon):\n    name = \"tvpaint\"\n    version = __version__\n    host_name = \"tvpaint\"\n\n    def add_implementation_envs(self, env, _app):\n        \"\"\"Modify environments to contain all required for implementation.\"\"\"\n\n        defaults = {\n            \"AYON_LOG_NO_COLORS\": \"1\"\n        }\n        for key, value in defaults.items():\n            if not env.get(key):\n                env[key] = value\n\n    def get_launch_hook_paths(self, app):\n        if app.host_name != self.host_name:\n            return []\n        return [\n            os.path.join(TVPAINT_ROOT_DIR, \"hooks\")\n        ]\n\n    def get_workfile_extensions(self):\n        return [\".tvpp\"]\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/addon.html#client.ayon_tvpaint.addon.TVPaintAddon.add_implementation_envs","title":"<code>add_implementation_envs(env, _app)</code>","text":"<p>Modify environments to contain all required for implementation.</p> Source code in <code>client/ayon_tvpaint/addon.py</code> <pre><code>def add_implementation_envs(self, env, _app):\n    \"\"\"Modify environments to contain all required for implementation.\"\"\"\n\n    defaults = {\n        \"AYON_LOG_NO_COLORS\": \"1\"\n    }\n    for key, value in defaults.items():\n        if not env.get(key):\n            env[key] = value\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.backwards_id_conversion","title":"<code>backwards_id_conversion(data_by_layer_id)</code>","text":"<p>Convert layer ids to strings from integers.</p> Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def backwards_id_conversion(data_by_layer_id):\n    \"\"\"Convert layer ids to strings from integers.\"\"\"\n    for key in tuple(data_by_layer_id.keys()):\n        if not isinstance(key, str):\n            data_by_layer_id[str(key)] = data_by_layer_id.pop(key)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.calculate_layer_frame_references","title":"<code>calculate_layer_frame_references(range_start, range_end, layer_frame_start, layer_frame_end, exposure_frames, pre_beh, post_beh)</code>","text":"<p>Calculate frame references for one layer based on it's data.</p> <p>Output is dictionary where key is frame index referencing to rendered frame index. If frame index should be rendered then is referencing to self.</p> <pre><code>// Example output\n{\n    1: 1, // Reference to self - will be rendered\n    2: 1, // Reference to frame 1 - will be copied\n    3: 1, // Reference to frame 1 - will be copied\n    4: 4, // Reference to self - will be rendered\n    ...\n    20: 4 // Reference to frame 4 - will be copied\n    21: None // Has reference to None - transparent image\n}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>range_start(int)</code> <p>First frame of range which should be rendered.</p> required <code>range_end(int)</code> <p>Last frame of range which should be rendered.</p> required <code>layer_frame_end(int)</code> <p>Last frame of layer.</p> required <code>exposure_frames(list)</code> <p>List of all exposure frames on layer.</p> required <code>pre_beh(str)</code> <p>Pre behavior of layer (enum of 4 strings).</p> required <code>post_beh(str)</code> <p>Post behavior of layer (enum of 4 strings).</p> required Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def calculate_layer_frame_references(\n    range_start, range_end,\n    layer_frame_start,\n    layer_frame_end,\n    exposure_frames,\n    pre_beh, post_beh\n):\n    \"\"\"Calculate frame references for one layer based on it's data.\n\n    Output is dictionary where key is frame index referencing to rendered frame\n    index. If frame index should be rendered then is referencing to self.\n\n    ```\n    // Example output\n    {\n        1: 1, // Reference to self - will be rendered\n        2: 1, // Reference to frame 1 - will be copied\n        3: 1, // Reference to frame 1 - will be copied\n        4: 4, // Reference to self - will be rendered\n        ...\n        20: 4 // Reference to frame 4 - will be copied\n        21: None // Has reference to None - transparent image\n    }\n    ```\n\n    Args:\n        range_start(int): First frame of range which should be rendered.\n        range_end(int): Last frame of range which should be rendered.\n        layer_frame_start(int)L First frame of layer.\n        layer_frame_end(int): Last frame of layer.\n        exposure_frames(list): List of all exposure frames on layer.\n        pre_beh(str): Pre behavior of layer (enum of 4 strings).\n        post_beh(str): Post behavior of layer (enum of 4 strings).\n    \"\"\"\n    # Output variable\n    output_idx_by_frame_idx = {}\n    # Skip if layer does not have any exposure frames\n    if not exposure_frames:\n        return output_idx_by_frame_idx\n\n    # First calculate in range frames\n    _calculate_in_range_frames(\n        range_start, range_end,\n        exposure_frames, layer_frame_end,\n        output_idx_by_frame_idx\n    )\n    # Calculate frames by pre behavior of layer\n    _calculate_pre_behavior_copy(\n        range_start, exposure_frames, pre_beh,\n        layer_frame_start, layer_frame_end,\n        output_idx_by_frame_idx\n    )\n    # Calculate frames by post behavior of layer\n    _calculate_post_behavior_copy(\n        range_end, exposure_frames, post_beh,\n        layer_frame_start, layer_frame_end,\n        output_idx_by_frame_idx\n    )\n    # Cleanup of referenced frames\n    _cleanup_frame_references(output_idx_by_frame_idx)\n\n    # Remove frames out of range\n    _cleanup_out_range_frames(output_idx_by_frame_idx, range_start, range_end)\n\n    return output_idx_by_frame_idx\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.calculate_layers_extraction_data","title":"<code>calculate_layers_extraction_data(layers_data, exposure_frames_by_layer_id, behavior_by_layer_id, range_start, range_end, skip_not_visible=True, filename_prefix=None, ext=None)</code>","text":"<p>Calculate extraction data for passed layers data.</p> <pre><code>{\n    &lt;layer_id&gt;: {\n        \"frame_references\": {...},\n        \"filenames_by_frame_index\": {...}\n    },\n    ...\n}\n</code></pre> <p>Frame references contains frame index reference to rendered frame index.</p> <p>Filename by frame index represents filename under which should be frame stored. Directory is not handled here because each usage may need different approach.</p> <p>Parameters:</p> Name Type Description Default <code>layers_data(list)</code> <p>Layers data loaded from TVPaint.</p> required <code>exposure_frames_by_layer_id(dict)</code> <p>Exposure frames of layers stored by layer id.</p> required <code>behavior_by_layer_id(dict)</code> <p>Pre and Post behavior of layers stored by layer id.</p> required <code>range_start(int)</code> <p>First frame of rendered range.</p> required <code>range_end(int)</code> <p>Last frame of rendered range.</p> required <code>skip_not_visible(bool)</code> <p>Skip calculations for hidden layers (Skipped by default).</p> required <code>filename_prefix(str)</code> <p>Prefix before filename.</p> required <code>ext(str)</code> <p>Extension which filenames will have ('.png' is default).</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Prepared data for rendering by layer position.</p> Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def calculate_layers_extraction_data(\n    layers_data,\n    exposure_frames_by_layer_id,\n    behavior_by_layer_id,\n    range_start,\n    range_end,\n    skip_not_visible=True,\n    filename_prefix=None,\n    ext=None\n):\n    \"\"\"Calculate extraction data for passed layers data.\n\n    ```\n    {\n        &lt;layer_id&gt;: {\n            \"frame_references\": {...},\n            \"filenames_by_frame_index\": {...}\n        },\n        ...\n    }\n    ```\n\n    Frame references contains frame index reference to rendered frame index.\n\n    Filename by frame index represents filename under which should be frame\n    stored. Directory is not handled here because each usage may need different\n    approach.\n\n    Args:\n        layers_data(list): Layers data loaded from TVPaint.\n        exposure_frames_by_layer_id(dict): Exposure frames of layers stored by\n            layer id.\n        behavior_by_layer_id(dict): Pre and Post behavior of layers stored by\n            layer id.\n        range_start(int): First frame of rendered range.\n        range_end(int): Last frame of rendered range.\n        skip_not_visible(bool): Skip calculations for hidden layers (Skipped\n            by default).\n        filename_prefix(str): Prefix before filename.\n        ext(str): Extension which filenames will have ('.png' is default).\n\n    Returns:\n        dict: Prepared data for rendering by layer position.\n    \"\"\"\n    # Make sure layer ids are strings\n    #   backwards compatibility when layer ids were integers\n    backwards_id_conversion(exposure_frames_by_layer_id)\n    backwards_id_conversion(behavior_by_layer_id)\n\n    layer_template = get_layer_pos_filename_template(\n        range_end, filename_prefix, ext\n    )\n    output = {}\n    for layer_data in layers_data:\n        if skip_not_visible and not layer_data[\"visible\"]:\n            continue\n\n        orig_layer_id = layer_data[\"layer_id\"]\n        layer_id = str(orig_layer_id)\n\n        # Skip if does not have any exposure frames (empty layer)\n        exposure_frames = exposure_frames_by_layer_id[layer_id]\n        if not exposure_frames:\n            continue\n\n        layer_position = layer_data[\"position\"]\n        layer_frame_start = layer_data[\"frame_start\"]\n        layer_frame_end = layer_data[\"frame_end\"]\n\n        layer_behavior = behavior_by_layer_id[layer_id]\n\n        pre_behavior = layer_behavior[\"pre\"]\n        post_behavior = layer_behavior[\"post\"]\n\n        frame_references = calculate_layer_frame_references(\n            range_start, range_end,\n            layer_frame_start,\n            layer_frame_end,\n            exposure_frames,\n            pre_behavior, post_behavior\n        )\n        # All values in 'frame_references' reference to a frame that must be\n        #   rendered out\n        frames_to_render = set(frame_references.values())\n        # Remove 'None' reference (transparent image)\n        if None in frames_to_render:\n            frames_to_render.remove(None)\n\n        # Skip layer if has nothing to render\n        if not frames_to_render:\n            continue\n\n        # All filenames that should be as output (not final output)\n        filename_frames = (\n            set(range(range_start, range_end + 1))\n            | frames_to_render\n        )\n        filenames_by_frame_index = {}\n        for frame_idx in filename_frames:\n            filenames_by_frame_index[frame_idx] = layer_template.format(\n                pos=layer_position,\n                frame=frame_idx\n            )\n\n        # Store objects under the layer id\n        output[orig_layer_id] = {\n            \"frame_references\": frame_references,\n            \"filenames_by_frame_index\": filenames_by_frame_index\n        }\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.cleanup_rendered_layers","title":"<code>cleanup_rendered_layers(filepaths_by_layer_id)</code>","text":"<p>Delete all files for each individual layer files after compositing.</p> Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def cleanup_rendered_layers(filepaths_by_layer_id):\n    \"\"\"Delete all files for each individual layer files after compositing.\"\"\"\n    # Collect all filepaths from data\n    all_filepaths = []\n    for filepaths_by_frame in filepaths_by_layer_id.values():\n        all_filepaths.extend(filepaths_by_frame.values())\n\n    # Loop over loop\n    for filepath in set(all_filepaths):\n        if filepath is not None and os.path.exists(filepath):\n            os.remove(filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.composite_images","title":"<code>composite_images(input_image_paths, output_filepath)</code>","text":"<p>Composite images in order from passed list.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When entered list is empty.</p> Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def composite_images(input_image_paths, output_filepath):\n    \"\"\"Composite images in order from passed list.\n\n    Raises:\n        ValueError: When entered list is empty.\n    \"\"\"\n    if not input_image_paths:\n        raise ValueError(\"Nothing to composite.\")\n\n    img_obj = None\n    for image_filepath in input_image_paths:\n        _img_obj = Image.open(image_filepath)\n        if img_obj is None:\n            img_obj = _img_obj\n        else:\n            img_obj.alpha_composite(_img_obj)\n    img_obj.save(output_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.composite_rendered_layers","title":"<code>composite_rendered_layers(layers_data, filepaths_by_layer_id, range_start, range_end, dst_filepaths_by_frame, cleanup=True)</code>","text":"<p>Composite multiple rendered layers by their position.</p> <p>Result is single frame sequence with transparency matching content created in TVPaint. Missing source filepaths are replaced with transparent images but at least one image must be rendered and exist.</p> <p>Function can be used even if single layer was created to fill transparent filepaths.</p> <p>Parameters:</p> Name Type Description Default <code>layers_data(list)</code> <p>Layers data loaded from TVPaint.</p> required <code>filepaths_by_layer_id(dict)</code> <p>Rendered filepaths stored by frame index per layer id. Used as source for compositing.</p> required <code>range_start(int)</code> <p>First frame of rendered range.</p> required <code>range_end(int)</code> <p>Last frame of rendered range.</p> required <code>dst_filepaths_by_frame(dict)</code> <p>Output filepaths by frame where final image after compositing will be stored. Path must not clash with source filepaths.</p> required <code>cleanup(bool)</code> <p>Remove all source filepaths when done with compositing.</p> required Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def composite_rendered_layers(\n    layers_data, filepaths_by_layer_id,\n    range_start, range_end,\n    dst_filepaths_by_frame, cleanup=True\n):\n    \"\"\"Composite multiple rendered layers by their position.\n\n    Result is single frame sequence with transparency matching content\n    created in TVPaint. Missing source filepaths are replaced with transparent\n    images but at least one image must be rendered and exist.\n\n    Function can be used even if single layer was created to fill transparent\n    filepaths.\n\n    Args:\n        layers_data(list): Layers data loaded from TVPaint.\n        filepaths_by_layer_id(dict): Rendered filepaths stored by frame index\n            per layer id. Used as source for compositing.\n        range_start(int): First frame of rendered range.\n        range_end(int): Last frame of rendered range.\n        dst_filepaths_by_frame(dict): Output filepaths by frame where final\n            image after compositing will be stored. Path must not clash with\n            source filepaths.\n        cleanup(bool): Remove all source filepaths when done with compositing.\n    \"\"\"\n    # Prepare layers by their position\n    #   - position tells in which order will compositing happen\n    layer_ids_by_position = {}\n    for layer in layers_data:\n        layer_position = layer[\"position\"]\n        layer_ids_by_position[layer_position] = layer[\"layer_id\"]\n\n    # Sort layer positions\n    sorted_positions = tuple(reversed(sorted(layer_ids_by_position.keys())))\n    # Prepare variable where filepaths without any rendered content\n    #   - transparent will be created\n    transparent_filepaths = set()\n    # Store first final filepath\n    first_dst_filepath = None\n    for frame_idx in range(range_start, range_end + 1):\n        dst_filepath = dst_filepaths_by_frame[frame_idx]\n        src_filepaths = []\n        for layer_position in sorted_positions:\n            layer_id = layer_ids_by_position[layer_position]\n            filepaths_by_frame = filepaths_by_layer_id[layer_id]\n            src_filepath = filepaths_by_frame.get(frame_idx)\n            if src_filepath is not None:\n                src_filepaths.append(src_filepath)\n\n        if not src_filepaths:\n            transparent_filepaths.add(dst_filepath)\n            continue\n\n        # Store first destination filepath to be used for transparent images\n        if first_dst_filepath is None:\n            first_dst_filepath = dst_filepath\n\n        if len(src_filepaths) == 1:\n            src_filepath = src_filepaths[0]\n            if cleanup:\n                os.rename(src_filepath, dst_filepath)\n            else:\n                copy_render_file(src_filepath, dst_filepath)\n\n        else:\n            composite_images(src_filepaths, dst_filepath)\n\n    # Store first transparent filepath to be able copy it\n    transparent_filepath = None\n    for dst_filepath in transparent_filepaths:\n        if transparent_filepath is None:\n            create_transparent_image_from_source(\n                first_dst_filepath, dst_filepath\n            )\n            transparent_filepath = dst_filepath\n        else:\n            copy_render_file(transparent_filepath, dst_filepath)\n\n    # Remove all files that were used as source for compositing\n    if cleanup:\n        cleanup_rendered_layers(filepaths_by_layer_id)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.copy_render_file","title":"<code>copy_render_file(src_path, dst_path)</code>","text":"<p>Create copy file of an image.</p> Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def copy_render_file(src_path, dst_path):\n    \"\"\"Create copy file of an image.\"\"\"\n    if hasattr(os, \"link\"):\n        os.link(src_path, dst_path)\n    else:\n        shutil.copy(src_path, dst_path)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.create_transparent_image_from_source","title":"<code>create_transparent_image_from_source(src_filepath, dst_filepath)</code>","text":"<p>Create transparent image of same type and size as source image.</p> Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def create_transparent_image_from_source(src_filepath, dst_filepath):\n    \"\"\"Create transparent image of same type and size as source image.\"\"\"\n    img_obj = Image.open(src_filepath)\n    painter = ImageDraw.Draw(img_obj)\n    painter.rectangle((0, 0, *img_obj.size), fill=(0, 0, 0, 0))\n    img_obj.save(dst_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.get_frame_filename_template","title":"<code>get_frame_filename_template(frame_end, filename_prefix=None, ext=None)</code>","text":"<p>Get file template with frame key for rendered files.</p> <p>This is simple template contains <code>{frame}{ext}</code> for sequential outputs and <code>single_file{ext}</code> for single file output. Output is rendered to temporary folder so filename should not matter as integrator change them.</p> Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def get_frame_filename_template(frame_end, filename_prefix=None, ext=None):\n    \"\"\"Get file template with frame key for rendered files.\n\n    This is simple template contains `{frame}{ext}` for sequential outputs\n    and `single_file{ext}` for single file output. Output is rendered to\n    temporary folder so filename should not matter as integrator change\n    them.\n    \"\"\"\n    frame_padding = 4\n    frame_end_str_len = len(str(frame_end))\n    if frame_end_str_len &gt; frame_padding:\n        frame_padding = frame_end_str_len\n\n    ext = ext or \".png\"\n    filename_prefix = filename_prefix or \"\"\n\n    return \"{}{{frame:0&gt;{}}}{}\".format(filename_prefix, frame_padding, ext)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/lib.html#client.ayon_tvpaint.lib.rename_filepaths_by_frame_start","title":"<code>rename_filepaths_by_frame_start(filepaths_by_frame, range_start, range_end, new_frame_start)</code>","text":"<p>Change frames in filenames of finished images to new frame start.</p> Source code in <code>client/ayon_tvpaint/lib.py</code> <pre><code>def rename_filepaths_by_frame_start(\n    filepaths_by_frame, range_start, range_end, new_frame_start\n):\n    \"\"\"Change frames in filenames of finished images to new frame start.\"\"\"\n\n    # Calculate frame end\n    new_frame_end = range_end + (new_frame_start - range_start)\n    # Create filename template\n    filename_template = get_frame_filename_template(\n        max(range_end, new_frame_end)\n    )\n\n    # Use different ranges based on Mark In and output Frame Start values\n    # - this is to make sure that filename renaming won't affect files that\n    #   are not renamed yet\n    if range_start &lt; new_frame_start:\n        source_range = range(range_end, range_start - 1, -1)\n        output_range = range(new_frame_end, new_frame_start - 1, -1)\n    else:\n        # This is less possible situation as frame start will be in most\n        #   cases higher than Mark In.\n        source_range = range(range_start, range_end + 1)\n        output_range = range(new_frame_start, new_frame_end + 1)\n\n    # Skip if source first frame is same as destination first frame\n    new_dst_filepaths = {}\n    for src_frame, dst_frame in zip(source_range, output_range):\n        src_filepath = os.path.normpath(filepaths_by_frame[src_frame])\n        dirpath, src_filename = os.path.split(src_filepath)\n        dst_filename = filename_template.format(frame=dst_frame)\n        dst_filepath = os.path.join(dirpath, dst_filename)\n\n        if src_filename != dst_filename:\n            os.rename(src_filepath, dst_filepath)\n\n        new_dst_filepaths[dst_frame] = dst_filepath\n\n    return new_dst_filepaths\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/version.html","title":"version","text":"<p>Package declaring AYON addon 'tvpaint' version.</p>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.CommunicationWrapper","title":"<code>CommunicationWrapper</code>","text":"Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>class CommunicationWrapper:\n    # TODO add logs and exceptions\n    communicator = None\n\n    log = logging.getLogger(\"CommunicationWrapper\")\n\n    @classmethod\n    def create_qt_communicator(cls, *args, **kwargs):\n        \"\"\"Create communicator for Artist usage.\"\"\"\n        communicator = QtCommunicator(*args, **kwargs)\n        cls.set_communicator(communicator)\n        return communicator\n\n    @classmethod\n    def set_communicator(cls, communicator):\n        if not cls.communicator:\n            cls.communicator = communicator\n        else:\n            cls.log.warning(\"Communicator was set multiple times.\")\n\n    @classmethod\n    def client(cls):\n        if not cls.communicator:\n            return None\n        return cls.communicator.client()\n\n    @classmethod\n    def execute_george(cls, george_script):\n        \"\"\"Execute passed goerge script in TVPaint.\"\"\"\n        if not cls.communicator:\n            return\n        return cls.communicator.execute_george(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.CommunicationWrapper.create_qt_communicator","title":"<code>create_qt_communicator(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create communicator for Artist usage.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>@classmethod\ndef create_qt_communicator(cls, *args, **kwargs):\n    \"\"\"Create communicator for Artist usage.\"\"\"\n    communicator = QtCommunicator(*args, **kwargs)\n    cls.set_communicator(communicator)\n    return communicator\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.CommunicationWrapper.execute_george","title":"<code>execute_george(george_script)</code>  <code>classmethod</code>","text":"<p>Execute passed goerge script in TVPaint.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>@classmethod\ndef execute_george(cls, george_script):\n    \"\"\"Execute passed goerge script in TVPaint.\"\"\"\n    if not cls.communicator:\n        return\n    return cls.communicator.execute_george(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.TVPaintHost","title":"<code>TVPaintHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>class TVPaintHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"tvpaint\"\n\n    def install(self):\n        \"\"\"Install TVPaint-specific functionality.\"\"\"\n\n        log.info(\"AYON - Installing TVPaint integration\")\n\n        # Create workdir folder if does not exist yet\n        workdir = os.getenv(\"AYON_WORKDIR\")\n        if not os.path.exists(workdir):\n            os.makedirs(workdir)\n\n        plugins_dir = os.path.join(TVPAINT_ROOT_DIR, \"plugins\")\n        publish_dir = os.path.join(plugins_dir, \"publish\")\n        load_dir = os.path.join(plugins_dir, \"load\")\n        create_dir = os.path.join(plugins_dir, \"create\")\n\n        pyblish.api.register_host(\"tvpaint\")\n        pyblish.api.register_plugin_path(publish_dir)\n        register_loader_plugin_path(load_dir)\n        register_creator_plugin_path(create_dir)\n\n        register_event_callback(\"application.launched\", self.initial_launch)\n        register_event_callback(\"application.exit\", self.application_exit)\n        register_event_callback(\n            \"workfile.open.after\",\n            self._on_workfile_open_after\n        )\n\n    def get_current_project_name(self):\n        \"\"\"\n        Returns:\n            Union[str, None]: Current project name.\n        \"\"\"\n\n        return self.get_current_context().get(\"project_name\")\n\n    def get_current_folder_path(self):\n        \"\"\"\n        Returns:\n            Union[str, None]: Current folder path.\n        \"\"\"\n\n        return self.get_current_context().get(\"folder_path\")\n\n    def get_current_task_name(self):\n        \"\"\"\n        Returns:\n            Union[str, None]: Current task name.\n        \"\"\"\n\n        return self.get_current_context().get(\"task_name\")\n\n    def get_current_context(self):\n        context = get_current_workfile_context()\n        if not context:\n            return get_global_context()\n\n        if \"project_name\" in context:\n            if \"asset_name\" in context:\n                context[\"folder_path\"] = context[\"asset_name\"]\n            return context\n        # This is legacy way how context was stored\n        return {\n            \"project_name\": context.get(\"project\"),\n            \"folder_path\": context.get(\"asset\"),\n            \"task_name\": context.get(\"task\")\n        }\n\n    # --- Create ---\n    def get_context_data(self):\n        return get_workfile_metadata(SECTION_NAME_CREATE_CONTEXT, {})\n\n    def update_context_data(self, data, changes):\n        return write_workfile_metadata(SECTION_NAME_CREATE_CONTEXT, data)\n\n    def list_instances(self):\n        \"\"\"List all created instances from current workfile.\"\"\"\n        return list_instances()\n\n    def write_instances(self, data):\n        return write_instances(data)\n\n    # --- Workfile ---\n    def open_workfile(self, filepath):\n        george_script = \"tv_LoadProject '\\\"'\\\"{}\\\"'\\\"'\".format(\n            filepath.replace(\"\\\\\", \"/\")\n        )\n        return execute_george_through_file(george_script)\n\n    def save_workfile(self, filepath=None):\n        if not filepath:\n            filepath = self.get_current_workfile()\n        context = get_global_context()\n        save_current_workfile_context(context)\n\n        # Execute george script to save workfile.\n        george_script = \"tv_SaveProject {}\".format(filepath.replace(\"\\\\\", \"/\"))\n        return execute_george(george_script)\n\n    def work_root(self, session):\n        return session[\"AYON_WORKDIR\"]\n\n    def get_current_workfile(self):\n        # TVPaint returns a '\\' character when no scene is currently opened\n        current_workfile = execute_george(\"tv_GetProjectName\")\n        if current_workfile == '\\\\':\n            return None\n        return current_workfile\n\n    def workfile_has_unsaved_changes(self):\n        return None\n\n    def get_workfile_extensions(self):\n        return [\".tvpp\"]\n\n    # --- Load ---\n    def get_containers(self):\n        return get_containers()\n\n    def initial_launch(self):\n        # Setup project context\n        # - if was used e.g. template the context might be invalid.\n        if not self.get_current_workfile():\n            return\n\n        log.info(\"Setting up context...\")\n        global_context = get_global_context()\n        project_name = global_context.get(\"project_name\")\n        if not project_name:\n            return\n\n        save_current_workfile_context(global_context)\n        # TODO fix 'set_context_settings'\n        return\n\n        folder_path = global_context.get(\"folder_path\")\n        task_name = global_context.get(\"task_name\")\n\n        if not folder_path:\n            return\n\n        folder_entity = ayon_api.get_folder_by_path(project_name, folder_path)\n        if folder_entity and task_name:\n            task_entity = ayon_api.get_task_by_name(\n                project_name,\n                folder_id=folder_entity[\"id\"],\n                task_name=task_name)\n            context_entity = task_entity\n        else:\n            log.warning(\n                \"Falling back to setting context settings using folder entity \"\n                \"because no task was found.\")\n            context_entity = folder_entity\n\n        set_context_settings(context_entity)\n\n    def application_exit(self):\n        \"\"\"Logic related to TimerManager.\n\n        Todo:\n            This should be handled out of TVPaint integration logic.\n        \"\"\"\n\n        data = get_current_project_settings()\n        stop_timer = data[\"tvpaint\"][\"stop_timer_on_application_exit\"]\n\n        if not stop_timer:\n            return\n\n        # Stop application timer.\n        webserver_url = os.environ.get(\"AYON_WEBSERVER_URL\")\n        rest_api_url = \"{}/timers_manager/stop_timer\".format(webserver_url)\n        requests.post(rest_api_url)\n\n    def _on_workfile_open_after(self):\n        # Make sure opened workfile has stored correct context\n        global_context = get_global_context()\n        save_current_workfile_context(global_context)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.TVPaintHost.application_exit","title":"<code>application_exit()</code>","text":"<p>Logic related to TimerManager.</p> Todo <p>This should be handled out of TVPaint integration logic.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def application_exit(self):\n    \"\"\"Logic related to TimerManager.\n\n    Todo:\n        This should be handled out of TVPaint integration logic.\n    \"\"\"\n\n    data = get_current_project_settings()\n    stop_timer = data[\"tvpaint\"][\"stop_timer_on_application_exit\"]\n\n    if not stop_timer:\n        return\n\n    # Stop application timer.\n    webserver_url = os.environ.get(\"AYON_WEBSERVER_URL\")\n    rest_api_url = \"{}/timers_manager/stop_timer\".format(webserver_url)\n    requests.post(rest_api_url)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.TVPaintHost.get_current_folder_path","title":"<code>get_current_folder_path()</code>","text":"<p>Returns:</p> Type Description <p>Union[str, None]: Current folder path.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_current_folder_path(self):\n    \"\"\"\n    Returns:\n        Union[str, None]: Current folder path.\n    \"\"\"\n\n    return self.get_current_context().get(\"folder_path\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.TVPaintHost.get_current_project_name","title":"<code>get_current_project_name()</code>","text":"<p>Returns:</p> Type Description <p>Union[str, None]: Current project name.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_current_project_name(self):\n    \"\"\"\n    Returns:\n        Union[str, None]: Current project name.\n    \"\"\"\n\n    return self.get_current_context().get(\"project_name\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.TVPaintHost.get_current_task_name","title":"<code>get_current_task_name()</code>","text":"<p>Returns:</p> Type Description <p>Union[str, None]: Current task name.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_current_task_name(self):\n    \"\"\"\n    Returns:\n        Union[str, None]: Current task name.\n    \"\"\"\n\n    return self.get_current_context().get(\"task_name\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.TVPaintHost.install","title":"<code>install()</code>","text":"<p>Install TVPaint-specific functionality.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install TVPaint-specific functionality.\"\"\"\n\n    log.info(\"AYON - Installing TVPaint integration\")\n\n    # Create workdir folder if does not exist yet\n    workdir = os.getenv(\"AYON_WORKDIR\")\n    if not os.path.exists(workdir):\n        os.makedirs(workdir)\n\n    plugins_dir = os.path.join(TVPAINT_ROOT_DIR, \"plugins\")\n    publish_dir = os.path.join(plugins_dir, \"publish\")\n    load_dir = os.path.join(plugins_dir, \"load\")\n    create_dir = os.path.join(plugins_dir, \"create\")\n\n    pyblish.api.register_host(\"tvpaint\")\n    pyblish.api.register_plugin_path(publish_dir)\n    register_loader_plugin_path(load_dir)\n    register_creator_plugin_path(create_dir)\n\n    register_event_callback(\"application.launched\", self.initial_launch)\n    register_event_callback(\"application.exit\", self.application_exit)\n    register_event_callback(\n        \"workfile.open.after\",\n        self._on_workfile_open_after\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/index.html#client.ayon_tvpaint.api.TVPaintHost.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def list_instances(self):\n    \"\"\"List all created instances from current workfile.\"\"\"\n    return list_instances()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html","title":"communication_server","text":""},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.BaseCommunicator","title":"<code>BaseCommunicator</code>","text":"Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>class BaseCommunicator:\n    def __init__(self):\n        self.process = None\n        self.websocket_server = None\n        self.websocket_rpc = None\n        self.exit_code = None\n        self._connected_client = None\n\n    @property\n    def server_is_running(self):\n        if self.websocket_server is None:\n            return False\n        return self.websocket_server.server_is_running\n\n    def _windows_file_process(self, src_dst_mapping, to_remove):\n        \"\"\"Windows specific file processing asking for admin permissions.\n\n        It is required to have administration permissions to modify plugin\n        files in TVPaint installation folder.\n\n        Method requires `pywin32` python module.\n\n        Args:\n            src_dst_mapping (list, tuple, set): Mapping of source file to\n                destination. Both must be full path. Each item must be iterable\n                of size 2 `(C:/src/file.dll, C:/dst/file.dll)`.\n            to_remove (list): Fullpath to files that should be removed.\n        \"\"\"\n\n        import pythoncom\n        from win32comext.shell import shell\n\n        # Create temp folder where plugin files are temporary copied\n        # - reason is that copy to TVPaint requires administartion permissions\n        #   but admin may not have access to source folder\n        tmp_dir = os.path.normpath(\n            tempfile.mkdtemp(prefix=\"tvpaint_copy_\")\n        )\n\n        # Copy source to temp folder and create new mapping\n        dst_folders = collections.defaultdict(list)\n        new_src_dst_mapping = []\n        for old_src, dst in src_dst_mapping:\n            new_src = os.path.join(tmp_dir, os.path.split(old_src)[1])\n            shutil.copy(old_src, new_src)\n            new_src_dst_mapping.append((new_src, dst))\n\n        for src, dst in new_src_dst_mapping:\n            src = os.path.normpath(src)\n            dst = os.path.normpath(dst)\n            dst_filename = os.path.basename(dst)\n            dst_folder_path = os.path.dirname(dst)\n            dst_folders[dst_folder_path].append((dst_filename, src))\n\n        # create an instance of IFileOperation\n        fo = pythoncom.CoCreateInstance(\n            shell.CLSID_FileOperation,\n            None,\n            pythoncom.CLSCTX_ALL,\n            shell.IID_IFileOperation\n        )\n        # Add delete command to file operation object\n        for filepath in to_remove:\n            item = shell.SHCreateItemFromParsingName(\n                filepath, None, shell.IID_IShellItem\n            )\n            fo.DeleteItem(item)\n\n        # here you can use SetOperationFlags, progress Sinks, etc.\n        for folder_path, items in dst_folders.items():\n            # create an instance of IShellItem for the target folder\n            folder_item = shell.SHCreateItemFromParsingName(\n                folder_path, None, shell.IID_IShellItem\n            )\n            for _dst_filename, source_file_path in items:\n                # create an instance of IShellItem for the source item\n                copy_item = shell.SHCreateItemFromParsingName(\n                    source_file_path, None, shell.IID_IShellItem\n                )\n                # queue the copy operation\n                fo.CopyItem(copy_item, folder_item, _dst_filename, None)\n\n        # commit\n        fo.PerformOperations()\n\n        # Remove temp folder\n        shutil.rmtree(tmp_dir)\n\n    def _prepare_windows_plugin(self, launch_args):\n        \"\"\"Copy plugin to TVPaint plugins and set PATH to dependencies.\n\n        Check if plugin in TVPaint's plugins exist and match to plugin\n        version to current implementation version. Based on 64-bit or 32-bit\n        version of the plugin. Path to libraries required for plugin is added\n        to PATH variable.\n        \"\"\"\n\n        host_executable = launch_args[0]\n        executable_file = os.path.basename(host_executable)\n        if \"64bit\" in executable_file:\n            subfolder = \"windows_x64\"\n        elif \"32bit\" in executable_file:\n            subfolder = \"windows_x86\"\n        else:\n            raise ValueError(\n                \"Can't determine if executable \"\n                \"leads to 32-bit or 64-bit TVPaint!\"\n            )\n\n        plugin_files_path = get_plugin_files_path()\n        # Folder for right windows plugin files\n        source_plugins_dir = os.path.join(plugin_files_path, subfolder)\n\n        # Path to libraries (.dll) required for plugin library\n        # - additional libraries can be copied to TVPaint installation folder\n        #   (next to executable) or added to PATH environment variable\n        additional_libs_folder = os.path.join(\n            source_plugins_dir,\n            \"additional_libraries\"\n        )\n        additional_libs_folder = additional_libs_folder.replace(\"\\\\\", \"/\")\n        if (\n            os.path.exists(additional_libs_folder)\n            and additional_libs_folder not in os.environ[\"PATH\"]\n        ):\n            os.environ[\"PATH\"] += (os.pathsep + additional_libs_folder)\n\n        # Path to TVPaint's plugins folder (where we want to add our plugin)\n        host_plugins_path = os.path.join(\n            os.path.dirname(host_executable),\n            \"plugins\"\n        )\n\n        # Files that must be copied to TVPaint's plugin folder\n        plugin_dir = os.path.join(source_plugins_dir, \"plugin\")\n\n        to_copy = []\n        to_remove = []\n        # Remove old plugin name\n        deprecated_filepath = os.path.join(\n            host_plugins_path, \"AvalonPlugin.dll\"\n        )\n        if os.path.exists(deprecated_filepath):\n            to_remove.append(deprecated_filepath)\n\n        for filename in os.listdir(plugin_dir):\n            src_full_path = os.path.join(plugin_dir, filename)\n            dst_full_path = os.path.join(host_plugins_path, filename)\n            if dst_full_path in to_remove:\n                to_remove.remove(dst_full_path)\n\n            if (\n                not os.path.exists(dst_full_path)\n                or not filecmp.cmp(src_full_path, dst_full_path)\n            ):\n                to_copy.append((src_full_path, dst_full_path))\n\n        # Skip copy if everything is done\n        if not to_copy and not to_remove:\n            return\n\n        # Try to copy\n        try:\n            self._windows_file_process(to_copy, to_remove)\n        except Exception:\n            log.error(\"Plugin copy failed\", exc_info=True)\n\n        # Validate copy was done\n        invalid_copy = []\n        for src, dst in to_copy:\n            if not os.path.exists(dst) or not filecmp.cmp(src, dst):\n                invalid_copy.append((src, dst))\n\n        # Validate delete was dones\n        invalid_remove = []\n        for filepath in to_remove:\n            if os.path.exists(filepath):\n                invalid_remove.append(filepath)\n\n        if not invalid_remove and not invalid_copy:\n            return\n\n        msg_parts = []\n        if invalid_remove:\n            msg_parts.append(\n                \"Failed to remove files: {}\".format(\", \".join(invalid_remove))\n            )\n\n        if invalid_copy:\n            _invalid = [\n                \"\\\"{}\\\" -&gt; \\\"{}\\\"\".format(src, dst)\n                for src, dst in invalid_copy\n            ]\n            msg_parts.append(\n                \"Failed to copy files: {}\".format(\", \".join(_invalid))\n            )\n        raise RuntimeError(\" &amp; \".join(msg_parts))\n\n    def _launch_tv_paint(self, launch_args):\n        flags = (\n            subprocess.DETACHED_PROCESS\n            | subprocess.CREATE_NEW_PROCESS_GROUP\n        )\n        env = os.environ.copy()\n        # Remove QuickTime from PATH on windows\n        # - quicktime overrides TVPaint's ffmpeg encode/decode which may\n        #   cause issues on loading\n        if platform.system().lower() == \"windows\":\n            new_path = []\n            for path in env[\"PATH\"].split(os.pathsep):\n                if path and \"quicktime\" not in path.lower():\n                    new_path.append(path)\n            env[\"PATH\"] = os.pathsep.join(new_path)\n\n        kwargs = {\n            \"env\": env,\n            \"creationflags\": flags\n        }\n        self.process = subprocess.Popen(launch_args, **kwargs)\n\n    def _create_routes(self):\n        self.websocket_rpc = BaseTVPaintRpc(\n            self, loop=self.websocket_server.loop\n        )\n        self.websocket_server.add_route(\n            \"*\", \"/\", self.websocket_rpc.handle_request\n        )\n\n    def _start_webserver(self):\n        self.websocket_server.start()\n        # Make sure RPC is using same loop as websocket server\n        while not self.websocket_server.server_is_running:\n            time.sleep(0.1)\n\n    def _stop_webserver(self):\n        self.websocket_server.stop()\n\n    def _exit(self, exit_code=None):\n        self._stop_webserver()\n        if exit_code is not None:\n            self.exit_code = exit_code\n\n        if self.exit_code is None:\n            self.exit_code = 0\n\n    def stop(self):\n        \"\"\"Stop communication and currently running python process.\"\"\"\n        log.info(\"Stopping communication\")\n        self._exit()\n\n    def launch(self, launch_args):\n        \"\"\"Prepare all required data and launch host.\n\n        First is prepared websocket server as communication point for host,\n        when server is ready to use host is launched as subprocess.\n        \"\"\"\n        if platform.system().lower() == \"windows\":\n            self._prepare_windows_plugin(launch_args)\n\n        # Launch TVPaint and the websocket server.\n        log.info(\"Launching TVPaint\")\n        self.websocket_server = WebSocketServer()\n\n        self._create_routes()\n        server_url = f\"ws://localhost:{self.websocket_server.port}\"\n        os.environ[\"AYON_RPC_URL\"] = server_url\n        log.info(f\"Added request handler for url: {server_url}\")\n\n        self._start_webserver()\n\n        # Start TVPaint when server is running\n        self._launch_tv_paint(launch_args)\n\n        log.info(\"Waiting for client connection\")\n        while True:\n            if self.process.poll() is not None:\n                log.debug(\"Host process is not alive. Exiting\")\n                self._exit(1)\n                return\n\n            if self.websocket_rpc.client_connected():\n                log.info(\"Client has connected\")\n                break\n            time.sleep(0.5)\n\n        self._on_client_connect()\n\n        emit_event(\"application.launched\")\n\n    def _on_client_connect(self):\n        self._initial_textfile_write()\n\n    def _initial_textfile_write(self):\n        \"\"\"Show popup about Write to file at start of TVPaint.\"\"\"\n        tmp_file = tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n        )\n        tmp_file.close()\n        tmp_filepath = tmp_file.name.replace(\"\\\\\", \"/\")\n        george_script = (\n            \"tv_writetextfile \\\"strict\\\" \\\"append\\\" \\\"{}\\\" \\\"empty\\\"\"\n        ).format(tmp_filepath)\n\n        result = CommunicationWrapper.execute_george(george_script)\n\n        # Remote the file\n        os.remove(tmp_filepath)\n\n        if result is None:\n            log.warning(\n                \"Host was probably closed before plugin was initialized.\"\n            )\n        elif result.lower() == \"forbidden\":\n            log.warning(\"User didn't confirm saving files.\")\n\n    def _client(self):\n        if not self.websocket_rpc:\n            log.warning(\"Communicator's server did not start yet.\")\n            return None\n\n        for client in self.websocket_rpc.clients:\n            if not client.ws.closed:\n                return client\n        log.warning(\"Client is not yet connected to Communicator.\")\n        return None\n\n    def client(self):\n        if not self._connected_client or self._connected_client.ws.closed:\n            self._connected_client = self._client()\n        return self._connected_client\n\n    def send_request(self, method, params=None):\n        client = self.client()\n        if not client:\n            return\n\n        return self.websocket_rpc.send_request(\n            client, method, params\n        )\n\n    def send_notification(self, method, params=None):\n        client = self.client()\n        if not client:\n            return\n\n        self.websocket_rpc.send_notification(\n            client, method, params\n        )\n\n    def execute_george(self, george_script):\n        \"\"\"Execute passed goerge script in TVPaint.\"\"\"\n        return self.send_request(\n            \"execute_george\", [george_script]\n        )\n\n    def execute_george_through_file(self, george_script):\n        \"\"\"Execute george script with temp file.\n\n        Allows to execute multiline george script without stopping websocket\n        client.\n\n        On windows make sure script does not contain paths with backwards\n        slashes in paths, TVPaint won't execute properly in that case.\n\n        Args:\n            george_script (str): George script to execute. May be multilined.\n        \"\"\"\n        temporary_file = tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"a_tvp_\", suffix=\".grg\", delete=False\n        )\n        temporary_file.write(george_script)\n        temporary_file.close()\n        temp_file_path = temporary_file.name.replace(\"\\\\\", \"/\")\n        self.execute_george(\"tv_runscript {}\".format(temp_file_path))\n        os.remove(temp_file_path)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.BaseCommunicator.execute_george","title":"<code>execute_george(george_script)</code>","text":"<p>Execute passed goerge script in TVPaint.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def execute_george(self, george_script):\n    \"\"\"Execute passed goerge script in TVPaint.\"\"\"\n    return self.send_request(\n        \"execute_george\", [george_script]\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.BaseCommunicator.execute_george_through_file","title":"<code>execute_george_through_file(george_script)</code>","text":"<p>Execute george script with temp file.</p> <p>Allows to execute multiline george script without stopping websocket client.</p> <p>On windows make sure script does not contain paths with backwards slashes in paths, TVPaint won't execute properly in that case.</p> <p>Parameters:</p> Name Type Description Default <code>george_script</code> <code>str</code> <p>George script to execute. May be multilined.</p> required Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def execute_george_through_file(self, george_script):\n    \"\"\"Execute george script with temp file.\n\n    Allows to execute multiline george script without stopping websocket\n    client.\n\n    On windows make sure script does not contain paths with backwards\n    slashes in paths, TVPaint won't execute properly in that case.\n\n    Args:\n        george_script (str): George script to execute. May be multilined.\n    \"\"\"\n    temporary_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"a_tvp_\", suffix=\".grg\", delete=False\n    )\n    temporary_file.write(george_script)\n    temporary_file.close()\n    temp_file_path = temporary_file.name.replace(\"\\\\\", \"/\")\n    self.execute_george(\"tv_runscript {}\".format(temp_file_path))\n    os.remove(temp_file_path)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.BaseCommunicator.launch","title":"<code>launch(launch_args)</code>","text":"<p>Prepare all required data and launch host.</p> <p>First is prepared websocket server as communication point for host, when server is ready to use host is launched as subprocess.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def launch(self, launch_args):\n    \"\"\"Prepare all required data and launch host.\n\n    First is prepared websocket server as communication point for host,\n    when server is ready to use host is launched as subprocess.\n    \"\"\"\n    if platform.system().lower() == \"windows\":\n        self._prepare_windows_plugin(launch_args)\n\n    # Launch TVPaint and the websocket server.\n    log.info(\"Launching TVPaint\")\n    self.websocket_server = WebSocketServer()\n\n    self._create_routes()\n    server_url = f\"ws://localhost:{self.websocket_server.port}\"\n    os.environ[\"AYON_RPC_URL\"] = server_url\n    log.info(f\"Added request handler for url: {server_url}\")\n\n    self._start_webserver()\n\n    # Start TVPaint when server is running\n    self._launch_tv_paint(launch_args)\n\n    log.info(\"Waiting for client connection\")\n    while True:\n        if self.process.poll() is not None:\n            log.debug(\"Host process is not alive. Exiting\")\n            self._exit(1)\n            return\n\n        if self.websocket_rpc.client_connected():\n            log.info(\"Client has connected\")\n            break\n        time.sleep(0.5)\n\n    self._on_client_connect()\n\n    emit_event(\"application.launched\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.BaseCommunicator.stop","title":"<code>stop()</code>","text":"<p>Stop communication and currently running python process.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def stop(self):\n    \"\"\"Stop communication and currently running python process.\"\"\"\n    log.info(\"Stopping communication\")\n    self._exit()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.CommunicationWrapper","title":"<code>CommunicationWrapper</code>","text":"Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>class CommunicationWrapper:\n    # TODO add logs and exceptions\n    communicator = None\n\n    log = logging.getLogger(\"CommunicationWrapper\")\n\n    @classmethod\n    def create_qt_communicator(cls, *args, **kwargs):\n        \"\"\"Create communicator for Artist usage.\"\"\"\n        communicator = QtCommunicator(*args, **kwargs)\n        cls.set_communicator(communicator)\n        return communicator\n\n    @classmethod\n    def set_communicator(cls, communicator):\n        if not cls.communicator:\n            cls.communicator = communicator\n        else:\n            cls.log.warning(\"Communicator was set multiple times.\")\n\n    @classmethod\n    def client(cls):\n        if not cls.communicator:\n            return None\n        return cls.communicator.client()\n\n    @classmethod\n    def execute_george(cls, george_script):\n        \"\"\"Execute passed goerge script in TVPaint.\"\"\"\n        if not cls.communicator:\n            return\n        return cls.communicator.execute_george(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.CommunicationWrapper.create_qt_communicator","title":"<code>create_qt_communicator(*args, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create communicator for Artist usage.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>@classmethod\ndef create_qt_communicator(cls, *args, **kwargs):\n    \"\"\"Create communicator for Artist usage.\"\"\"\n    communicator = QtCommunicator(*args, **kwargs)\n    cls.set_communicator(communicator)\n    return communicator\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.CommunicationWrapper.execute_george","title":"<code>execute_george(george_script)</code>  <code>classmethod</code>","text":"<p>Execute passed goerge script in TVPaint.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>@classmethod\ndef execute_george(cls, george_script):\n    \"\"\"Execute passed goerge script in TVPaint.\"\"\"\n    if not cls.communicator:\n        return\n    return cls.communicator.execute_george(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.MainThreadItem","title":"<code>MainThreadItem</code>","text":"<p>Structure to store information about callback in main thread.</p> <p>Item should be used to execute callback in main thread which may be needed for execution of Qt objects.</p> <p>Item store callback (callable variable), arguments and keyword arguments for the callback. Item hold information about it's process.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>class MainThreadItem:\n    \"\"\"Structure to store information about callback in main thread.\n\n    Item should be used to execute callback in main thread which may be needed\n    for execution of Qt objects.\n\n    Item store callback (callable variable), arguments and keyword arguments\n    for the callback. Item hold information about it's process.\n    \"\"\"\n    not_set = object()\n    sleep_time = 0.1\n\n    def __init__(self, callback, *args, **kwargs):\n        self.done = False\n        self.exception = self.not_set\n        self.result = self.not_set\n        self.callback = callback\n        self.args = args\n        self.kwargs = kwargs\n\n    def execute(self):\n        \"\"\"Execute callback and store its result.\n\n        Method must be called from main thread. Item is marked as `done`\n        when callback execution finished. Store output of callback of exception\n        information when callback raises one.\n        \"\"\"\n        log.debug(\"Executing process in main thread\")\n        if self.done:\n            log.warning(\"- item is already processed\")\n            return\n\n        callback = self.callback\n        args = self.args\n        kwargs = self.kwargs\n        log.info(\"Running callback: {}\".format(str(callback)))\n        try:\n            result = callback(*args, **kwargs)\n            self.result = result\n\n        except Exception as exc:\n            self.exception = exc\n\n        finally:\n            self.done = True\n\n    def wait(self):\n        \"\"\"Wait for result from main thread.\n\n        This method stops current thread until callback is executed.\n\n        Returns:\n            object: Output of callback. May be any type or object.\n\n        Raises:\n            Exception: Reraise any exception that happened during callback\n                execution.\n        \"\"\"\n        while not self.done:\n            time.sleep(self.sleep_time)\n\n        if self.exception is self.not_set:\n            return self.result\n        raise self.exception\n\n    async def async_wait(self):\n        \"\"\"Wait for result from main thread.\n\n        Returns:\n            object: Output of callback. May be any type or object.\n\n        Raises:\n            Exception: Reraise any exception that happened during callback\n                execution.\n        \"\"\"\n        while not self.done:\n            await asyncio.sleep(self.sleep_time)\n\n        if self.exception is self.not_set:\n            return self.result\n        raise self.exception\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.MainThreadItem.async_wait","title":"<code>async_wait()</code>  <code>async</code>","text":"<p>Wait for result from main thread.</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Output of callback. May be any type or object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Reraise any exception that happened during callback execution.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>async def async_wait(self):\n    \"\"\"Wait for result from main thread.\n\n    Returns:\n        object: Output of callback. May be any type or object.\n\n    Raises:\n        Exception: Reraise any exception that happened during callback\n            execution.\n    \"\"\"\n    while not self.done:\n        await asyncio.sleep(self.sleep_time)\n\n    if self.exception is self.not_set:\n        return self.result\n    raise self.exception\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.MainThreadItem.execute","title":"<code>execute()</code>","text":"<p>Execute callback and store its result.</p> <p>Method must be called from main thread. Item is marked as <code>done</code> when callback execution finished. Store output of callback of exception information when callback raises one.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def execute(self):\n    \"\"\"Execute callback and store its result.\n\n    Method must be called from main thread. Item is marked as `done`\n    when callback execution finished. Store output of callback of exception\n    information when callback raises one.\n    \"\"\"\n    log.debug(\"Executing process in main thread\")\n    if self.done:\n        log.warning(\"- item is already processed\")\n        return\n\n    callback = self.callback\n    args = self.args\n    kwargs = self.kwargs\n    log.info(\"Running callback: {}\".format(str(callback)))\n    try:\n        result = callback(*args, **kwargs)\n        self.result = result\n\n    except Exception as exc:\n        self.exception = exc\n\n    finally:\n        self.done = True\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.MainThreadItem.wait","title":"<code>wait()</code>","text":"<p>Wait for result from main thread.</p> <p>This method stops current thread until callback is executed.</p> <p>Returns:</p> Name Type Description <code>object</code> <p>Output of callback. May be any type or object.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Reraise any exception that happened during callback execution.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def wait(self):\n    \"\"\"Wait for result from main thread.\n\n    This method stops current thread until callback is executed.\n\n    Returns:\n        object: Output of callback. May be any type or object.\n\n    Raises:\n        Exception: Reraise any exception that happened during callback\n            execution.\n    \"\"\"\n    while not self.done:\n        time.sleep(self.sleep_time)\n\n    if self.exception is self.not_set:\n        return self.result\n    raise self.exception\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.QtCommunicator","title":"<code>QtCommunicator</code>","text":"<p>               Bases: <code>BaseCommunicator</code></p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>class QtCommunicator(BaseCommunicator):\n    label = os.getenv(\"AYON_MENU_LABEL\") or \"AYON\"\n    title = \"{} Tools\".format(label)\n    menu_definitions = {\n        \"title\": title,\n        \"menu_items\": [\n            {\n                \"callback\": \"workfiles_tool\",\n                \"label\": \"Workfiles\",\n                \"help\": \"Open workfiles tool\"\n            }, {\n                \"callback\": \"loader_tool\",\n                \"label\": \"Load\",\n                \"help\": \"Open loader tool\"\n            }, {\n                \"callback\": \"scene_inventory_tool\",\n                \"label\": \"Scene inventory\",\n                \"help\": \"Open scene inventory tool\"\n            }, {\n                \"callback\": \"publish_tool\",\n                \"label\": \"Publish\",\n                \"help\": \"Open publisher\"\n            }, {\n                \"callback\": \"library_loader_tool\",\n                \"label\": \"Library\",\n                \"help\": \"Open library loader tool\"\n            }, {\n                \"callback\": \"experimental_tools\",\n                \"label\": \"Experimental tools\",\n                \"help\": \"Open experimental tools dialog\"\n            }\n        ]\n    }\n\n    def __init__(self, qt_app):\n        super().__init__()\n        self.callback_queue = collections.deque()\n        self.qt_app = qt_app\n\n    def _create_routes(self):\n        self.websocket_rpc = QtTVPaintRpc(\n            self, loop=self.websocket_server.loop\n        )\n        self.websocket_server.add_route(\n            \"*\", \"/\", self.websocket_rpc.handle_request\n        )\n\n    def execute_in_main_thread(self, main_thread_item, wait=True):\n        \"\"\"Add `MainThreadItem` to callback queue and wait for result.\"\"\"\n        self.callback_queue.append(main_thread_item)\n        if wait:\n            return main_thread_item.wait()\n        return\n\n    async def async_execute_in_main_thread(self, main_thread_item, wait=True):\n        \"\"\"Add `MainThreadItem` to callback queue and wait for result.\"\"\"\n        self.callback_queue.append(main_thread_item)\n        if wait:\n            return await main_thread_item.async_wait()\n\n    def main_thread_listen(self):\n        \"\"\"Get last `MainThreadItem` from queue.\n\n        Must be called from main thread.\n\n        Method checks if host process is still running as it may cause\n        issues if not.\n        \"\"\"\n        # check if host still running\n        if self.process.poll() is not None:\n            self._exit()\n            return None\n\n        if self.callback_queue:\n            return self.callback_queue.popleft()\n        return None\n\n    def _on_client_connect(self):\n        super()._on_client_connect()\n        self._build_menu()\n\n    def _build_menu(self):\n        self.send_request(\n            \"define_menu\", [self.menu_definitions]\n        )\n\n    def _exit(self, *args, **kwargs):\n        super()._exit(*args, **kwargs)\n        emit_event(\"application.exit\")\n        self.qt_app.exit(self.exit_code)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.QtCommunicator.async_execute_in_main_thread","title":"<code>async_execute_in_main_thread(main_thread_item, wait=True)</code>  <code>async</code>","text":"<p>Add <code>MainThreadItem</code> to callback queue and wait for result.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>async def async_execute_in_main_thread(self, main_thread_item, wait=True):\n    \"\"\"Add `MainThreadItem` to callback queue and wait for result.\"\"\"\n    self.callback_queue.append(main_thread_item)\n    if wait:\n        return await main_thread_item.async_wait()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.QtCommunicator.execute_in_main_thread","title":"<code>execute_in_main_thread(main_thread_item, wait=True)</code>","text":"<p>Add <code>MainThreadItem</code> to callback queue and wait for result.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def execute_in_main_thread(self, main_thread_item, wait=True):\n    \"\"\"Add `MainThreadItem` to callback queue and wait for result.\"\"\"\n    self.callback_queue.append(main_thread_item)\n    if wait:\n        return main_thread_item.wait()\n    return\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.QtCommunicator.main_thread_listen","title":"<code>main_thread_listen()</code>","text":"<p>Get last <code>MainThreadItem</code> from queue.</p> <p>Must be called from main thread.</p> <p>Method checks if host process is still running as it may cause issues if not.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def main_thread_listen(self):\n    \"\"\"Get last `MainThreadItem` from queue.\n\n    Must be called from main thread.\n\n    Method checks if host process is still running as it may cause\n    issues if not.\n    \"\"\"\n    # check if host still running\n    if self.process.poll() is not None:\n        self._exit()\n        return None\n\n    if self.callback_queue:\n        return self.callback_queue.popleft()\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.QtTVPaintRpc","title":"<code>QtTVPaintRpc</code>","text":"<p>               Bases: <code>BaseTVPaintRpc</code></p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>class QtTVPaintRpc(BaseTVPaintRpc):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        from ayon_core.tools.utils import host_tools\n        self.tools_helper = host_tools.HostToolsHelper()\n\n        route_name = self.route_name\n\n        # Register methods\n        self.add_methods(\n            (route_name, self.workfiles_tool),\n            (route_name, self.loader_tool),\n            (route_name, self.publish_tool),\n            (route_name, self.scene_inventory_tool),\n            (route_name, self.library_loader_tool),\n            (route_name, self.experimental_tools)\n        )\n\n    # Panel routes for tools\n    async def workfiles_tool(self):\n        log.info(\"Triggering Workfile tool\")\n        item = MainThreadItem(self.tools_helper.show_workfiles)\n        self._execute_in_main_thread(item, wait=False)\n        return\n\n    async def loader_tool(self):\n        log.info(\"Triggering Loader tool\")\n        item = MainThreadItem(self.tools_helper.show_loader)\n        self._execute_in_main_thread(item, wait=False)\n        return\n\n    async def publish_tool(self):\n        log.info(\"Triggering Publish tool\")\n        item = MainThreadItem(self.tools_helper.show_publisher_tool)\n        self._execute_in_main_thread(item, wait=False)\n        return\n\n    async def scene_inventory_tool(self):\n        \"\"\"Open Scene Inventory tool.\n\n        Function can't confirm if tool was opened becauise one part of\n        SceneInventory initialization is calling websocket request to host but\n        host can't response because is waiting for response from this call.\n        \"\"\"\n        log.info(\"Triggering Scene inventory tool\")\n        item = MainThreadItem(self.tools_helper.show_scene_inventory)\n        # Do not wait for result of callback\n        self._execute_in_main_thread(item, wait=False)\n        return\n\n    async def library_loader_tool(self):\n        log.info(\"Triggering Library loader tool\")\n        item = MainThreadItem(self.tools_helper.show_library_loader)\n        self._execute_in_main_thread(item, wait=False)\n        return\n\n    async def experimental_tools(self):\n        log.info(\"Triggering Library loader tool\")\n        item = MainThreadItem(self.tools_helper.show_experimental_tools_dialog)\n        self._execute_in_main_thread(item, wait=False)\n        return\n\n    async def _async_execute_in_main_thread(self, item, **kwargs):\n        await self.communication_obj.async_execute_in_main_thread(\n            item, **kwargs\n        )\n\n    def _execute_in_main_thread(self, item, **kwargs):\n        return self.communication_obj.execute_in_main_thread(item, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.QtTVPaintRpc.scene_inventory_tool","title":"<code>scene_inventory_tool()</code>  <code>async</code>","text":"<p>Open Scene Inventory tool.</p> <p>Function can't confirm if tool was opened becauise one part of SceneInventory initialization is calling websocket request to host but host can't response because is waiting for response from this call.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>async def scene_inventory_tool(self):\n    \"\"\"Open Scene Inventory tool.\n\n    Function can't confirm if tool was opened becauise one part of\n    SceneInventory initialization is calling websocket request to host but\n    host can't response because is waiting for response from this call.\n    \"\"\"\n    log.info(\"Triggering Scene inventory tool\")\n    item = MainThreadItem(self.tools_helper.show_scene_inventory)\n    # Do not wait for result of callback\n    self._execute_in_main_thread(item, wait=False)\n    return\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.WebsocketServerThread","title":"<code>WebsocketServerThread</code>","text":"<p>               Bases: <code>Thread</code></p> <p>Listener for websocket rpc requests.</p> <p>It would be probably better to \"attach\" this to main thread (as for example Harmony needs to run something on main thread), but currently it creates separate thread and separate asyncio event loop</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>class WebsocketServerThread(threading.Thread):\n    \"\"\" Listener for websocket rpc requests.\n\n        It would be probably better to \"attach\" this to main thread (as for\n        example Harmony needs to run something on main thread), but currently\n        it creates separate thread and separate asyncio event loop\n    \"\"\"\n    def __init__(self, module, port, loop):\n        super(WebsocketServerThread, self).__init__()\n        self.is_running = False\n        self.server_is_running = False\n        self.port = port\n        self.module = module\n        self.loop = loop\n        self.runner = None\n        self.site = None\n        self.tasks = []\n\n    def run(self):\n        self.is_running = True\n\n        try:\n            log.debug(\"Starting websocket server\")\n\n            self.loop.run_until_complete(self.start_server())\n\n            log.info(\n                \"Running Websocket server on URL:\"\n                \" \\\"ws://localhost:{}\\\"\".format(self.port)\n            )\n\n            asyncio.ensure_future(self.check_shutdown(), loop=self.loop)\n\n            self.server_is_running = True\n            self.loop.run_forever()\n\n        except Exception:\n            log.warning(\n                \"Websocket Server service has failed\", exc_info=True\n            )\n        finally:\n            self.server_is_running = False\n            # optional\n            self.loop.close()\n\n        self.is_running = False\n        log.info(\"Websocket server stopped\")\n\n    async def start_server(self):\n        \"\"\" Starts runner and TCPsite \"\"\"\n        self.runner = web.AppRunner(self.module.app)\n        await self.runner.setup()\n        self.site = web.TCPSite(self.runner, \"localhost\", self.port)\n        await self.site.start()\n\n    def stop(self):\n        \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n        self.is_running = False\n\n    async def check_shutdown(self):\n        \"\"\" Future that is running and checks if server should be running\n            periodically.\n        \"\"\"\n        while self.is_running:\n            while self.tasks:\n                task = self.tasks.pop(0)\n                log.debug(\"waiting for task {}\".format(task))\n                await task\n                log.debug(\"returned value {}\".format(task.result))\n\n            await asyncio.sleep(0.5)\n\n        log.debug(\"## Server shutdown started\")\n\n        await self.site.stop()\n        log.debug(\"# Site stopped\")\n        await self.runner.cleanup()\n        log.debug(\"# Server runner stopped\")\n        tasks = [\n            task for task in asyncio.all_tasks()\n            if task is not asyncio.current_task()\n        ]\n        list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        log.debug(f\"Finished awaiting cancelled tasks, results: {results}...\")\n        await self.loop.shutdown_asyncgens()\n        # to really make sure everything else has time to stop\n        await asyncio.sleep(0.07)\n        self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.WebsocketServerThread.check_shutdown","title":"<code>check_shutdown()</code>  <code>async</code>","text":"<p>Future that is running and checks if server should be running periodically.</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>async def check_shutdown(self):\n    \"\"\" Future that is running and checks if server should be running\n        periodically.\n    \"\"\"\n    while self.is_running:\n        while self.tasks:\n            task = self.tasks.pop(0)\n            log.debug(\"waiting for task {}\".format(task))\n            await task\n            log.debug(\"returned value {}\".format(task.result))\n\n        await asyncio.sleep(0.5)\n\n    log.debug(\"## Server shutdown started\")\n\n    await self.site.stop()\n    log.debug(\"# Site stopped\")\n    await self.runner.cleanup()\n    log.debug(\"# Server runner stopped\")\n    tasks = [\n        task for task in asyncio.all_tasks()\n        if task is not asyncio.current_task()\n    ]\n    list(map(lambda task: task.cancel(), tasks))  # cancel all the tasks\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    log.debug(f\"Finished awaiting cancelled tasks, results: {results}...\")\n    await self.loop.shutdown_asyncgens()\n    # to really make sure everything else has time to stop\n    await asyncio.sleep(0.07)\n    self.loop.stop()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.WebsocketServerThread.start_server","title":"<code>start_server()</code>  <code>async</code>","text":"<p>Starts runner and TCPsite</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>async def start_server(self):\n    \"\"\" Starts runner and TCPsite \"\"\"\n    self.runner = web.AppRunner(self.module.app)\n    await self.runner.setup()\n    self.site = web.TCPSite(self.runner, \"localhost\", self.port)\n    await self.site.start()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/communication_server.html#client.ayon_tvpaint.api.communication_server.WebsocketServerThread.stop","title":"<code>stop()</code>","text":"<p>Sets is_running flag to false, 'check_shutdown' shuts server down</p> Source code in <code>client/ayon_tvpaint/api/communication_server.py</code> <pre><code>def stop(self):\n    \"\"\"Sets is_running flag to false, 'check_shutdown' shuts server down\"\"\"\n    self.is_running = False\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/launch_script.html","title":"launch_script","text":""},{"location":"autoapi/client/ayon_tvpaint/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.execute_george_through_file","title":"<code>execute_george_through_file(george_script, communicator=None)</code>","text":"<p>Execute george script with temp file.</p> <p>Allows to execute multiline george script without stopping websocket client.</p> <p>On windows make sure script does not contain paths with backwards slashes in paths, TVPaint won't execute properly in that case.</p> <p>Parameters:</p> Name Type Description Default <code>george_script</code> <code>str</code> <p>George script to execute. May be multilined.</p> required Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def execute_george_through_file(george_script, communicator=None):\n    \"\"\"Execute george script with temp file.\n\n    Allows to execute multiline george script without stopping websocket\n    client.\n\n    On windows make sure script does not contain paths with backwards\n    slashes in paths, TVPaint won't execute properly in that case.\n\n    Args:\n        george_script (str): George script to execute. May be multilined.\n    \"\"\"\n    if not communicator:\n        communicator = CommunicationWrapper.communicator\n\n    return communicator.execute_george_through_file(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.get_exposure_frames","title":"<code>get_exposure_frames(layer_id, first_frame=None, last_frame=None, communicator=None)</code>","text":"<p>Get exposure frames.</p> <p>Easily said returns frames where keyframes are. Recognized with george function <code>tv_exposureinfo</code> returning \"Head\".</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>int</code> <p>Id of a layer for which exposure frames should look for.</p> required <code>first_frame</code> <code>int</code> <p>From which frame will look for exposure frames. Used layers first frame if not entered.</p> <code>None</code> <code>last_frame</code> <code>int</code> <p>Last frame where will look for exposure frames. Used layers last frame if not entered.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>Frames where exposure is set to \"Head\".</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def get_exposure_frames(\n    layer_id, first_frame=None, last_frame=None, communicator=None\n):\n    \"\"\"Get exposure frames.\n\n    Easily said returns frames where keyframes are. Recognized with george\n    function `tv_exposureinfo` returning \"Head\".\n\n    Args:\n        layer_id (int): Id of a layer for which exposure frames should\n            look for.\n        first_frame (int): From which frame will look for exposure frames.\n            Used layers first frame if not entered.\n        last_frame (int): Last frame where will look for exposure frames.\n            Used layers last frame if not entered.\n\n    Returns:\n        list: Frames where exposure is set to \"Head\".\n    \"\"\"\n    if first_frame is None or last_frame is None:\n        layer = layers_data(layer_id)[0]\n        if first_frame is None:\n            first_frame = layer[\"frame_start\"]\n        if last_frame is None:\n            last_frame = layer[\"frame_end\"]\n\n    tmp_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n    )\n    tmp_file.close()\n    tmp_output_path = tmp_file.name.replace(\"\\\\\", \"/\")\n    george_script_lines = [\n        \"tv_layerset {}\".format(layer_id),\n        \"output_path = \\\"{}\\\"\".format(tmp_output_path),\n        \"output = \\\"\\\"\",\n        \"frame = {}\".format(first_frame),\n        \"WHILE (frame &lt;= {})\".format(last_frame),\n        \"tv_exposureinfo frame\",\n        \"exposure = result\",\n        \"IF (CMP(exposure, \\\"Head\\\") == 1)\",\n        \"IF (CMP(output, \\\"\\\") == 1)\",\n        \"output = output''frame\",\n        \"ELSE\",\n        \"output = output'|'frame\",\n        \"END\",\n        \"END\",\n        \"frame = frame + 1\",\n        \"END\",\n        \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' output\"\n    ]\n\n    execute_george_through_file(\"\\n\".join(george_script_lines), communicator)\n\n    with open(tmp_output_path, \"r\") as stream:\n        data = stream.read()\n\n    os.remove(tmp_output_path)\n\n    lines = []\n    for line in data.split(\"\\n\"):\n        line = line.strip()\n        if line:\n            lines.append(line)\n\n    exposure_frames = []\n    for line in lines:\n        for frame in line.split(\"|\"):\n            exposure_frames.append(int(frame))\n    return exposure_frames\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.get_groups_data","title":"<code>get_groups_data(communicator=None)</code>","text":"<p>Information about groups from current workfile.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def get_groups_data(communicator=None):\n    \"\"\"Information about groups from current workfile.\"\"\"\n    output_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n    )\n    output_file.close()\n\n    output_filepath = output_file.name.replace(\"\\\\\", \"/\")\n    george_script_lines = (\n        # Variable containing full path to output file\n        \"output_path = \\\"{}\\\"\".format(output_filepath),\n        \"empty = 0\",\n        # Loop over 26 groups which is ATM maximum possible (in 11.7)\n        # - ref: https://www.tvpaint.com/forum/viewtopic.php?t=13880\n        \"FOR idx = 1 TO 26\",\n        # Receive information about groups\n        \"tv_layercolor \\\"getcolor\\\" 0 idx\",\n        \"PARSE result clip_id group_index c_red c_green c_blue group_name\",\n        # Create and add line to output file\n        \"line = clip_id'|'group_index'|'c_red'|'c_green'|'c_blue'|'group_name\",\n        \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' line\",\n        \"END\",\n    )\n    george_script = \"\\n\".join(george_script_lines)\n    execute_george_through_file(george_script, communicator)\n\n    with open(output_filepath, \"r\") as stream:\n        data = stream.read()\n\n    output = parse_group_data(data)\n    os.remove(output_filepath)\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.get_layers_data","title":"<code>get_layers_data(layer_ids=None, communicator=None)</code>","text":"<p>Collect all layers information from currently opened workfile.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def get_layers_data(layer_ids=None, communicator=None):\n    \"\"\"Collect all layers information from currently opened workfile.\"\"\"\n    output_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n    )\n    output_file.close()\n    if layer_ids is not None and isinstance(layer_ids, int):\n        layer_ids = [layer_ids]\n\n    output_filepath = output_file.name\n\n    george_script = get_layers_data_george_script(output_filepath, layer_ids)\n\n    execute_george_through_file(george_script, communicator)\n\n    with open(output_filepath, \"r\") as stream:\n        data = stream.read()\n\n    output = parse_layers_data(data)\n    os.remove(output_filepath)\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.get_layers_data_george_script","title":"<code>get_layers_data_george_script(output_filepath, layer_ids=None)</code>","text":"<p>Prepare george script which will collect all layers from workfile.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def get_layers_data_george_script(output_filepath, layer_ids=None):\n    \"\"\"Prepare george script which will collect all layers from workfile.\"\"\"\n    output_filepath = output_filepath.replace(\"\\\\\", \"/\")\n    george_script_lines = [\n        # Variable containing full path to output file\n        \"output_path = \\\"{}\\\"\".format(output_filepath),\n        # Get Current Layer ID\n        \"tv_LayerCurrentID\",\n        \"current_layer_id = result\"\n    ]\n    # Script part for getting and storing layer information to temp\n    layer_data_getter = (\n        # Get information about layer's group\n        \"tv_layercolor \\\"get\\\" layer_id\",\n        \"group_id = result\",\n        \"tv_LayerInfo layer_id\",\n        (\n            \"PARSE result visible position opacity name\"\n            \" type startFrame endFrame prelighttable postlighttable\"\n            \" selected editable sencilState\"\n        ),\n        # Check if layer ID match `tv_LayerCurrentID`\n        \"is_current=0\",\n        \"IF CMP(current_layer_id, layer_id)==1\",\n        # - mark layer as selected if layer id match to current layer id\n        \"is_current=1\",\n        \"selected=1\",\n        \"END\",\n        # Prepare line with data separated by \"|\"\n        (\n            \"line = layer_id'|'group_id'|'visible'|'position'|'opacity'|'\"\n            \"name'|'type'|'startFrame'|'endFrame'|'prelighttable'|'\"\n            \"postlighttable'|'selected'|'editable'|'sencilState'|'is_current\"\n        ),\n        # Write data to output file\n        \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' line\",\n    )\n\n    # Collect data for all layers if layers are not specified\n    if layer_ids is None:\n        george_script_lines.extend((\n            # Layer loop variables\n            \"loop = 1\",\n            \"idx = 0\",\n            # Layers loop\n            \"WHILE loop\",\n            \"tv_LayerGetID idx\",\n            \"layer_id = result\",\n            \"idx = idx + 1\",\n            # Stop loop if layer_id is \"NONE\"\n            \"IF CMP(layer_id, \\\"NONE\\\")==1\",\n            \"loop = 0\",\n            \"ELSE\",\n            *layer_data_getter,\n            \"END\",\n            \"END\"\n        ))\n    else:\n        for layer_id in layer_ids:\n            george_script_lines.append(\"layer_id = {}\".format(layer_id))\n            george_script_lines.extend(layer_data_getter)\n\n    return \"\\n\".join(george_script_lines)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.get_layers_exposure_frames","title":"<code>get_layers_exposure_frames(layer_ids, layers_data=None, communicator=None)</code>","text":"<p>Get exposure frames.</p> <p>Easily said returns frames where keyframes are. Recognized with george function <code>tv_exposureinfo</code> returning \"Head\".</p> <p>Parameters:</p> Name Type Description Default <code>layer_ids</code> <code>list</code> <p>Ids of a layers for which exposure frames should look for.</p> required <code>layers_data</code> <code>list</code> <p>Precollected layers data. If are not passed then 'get_layers_data' is used.</p> <code>None</code> <code>communicator</code> <code>BaseCommunicator</code> <p>Communicator used for communication with TVPaint.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Frames where exposure is set to \"Head\" by layer id.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def get_layers_exposure_frames(layer_ids, layers_data=None, communicator=None):\n    \"\"\"Get exposure frames.\n\n    Easily said returns frames where keyframes are. Recognized with george\n    function `tv_exposureinfo` returning \"Head\".\n\n    Args:\n        layer_ids (list): Ids of a layers for which exposure frames should\n            look for.\n        layers_data (list): Precollected layers data. If are not passed then\n            'get_layers_data' is used.\n        communicator (BaseCommunicator): Communicator used for communication\n            with TVPaint.\n\n    Returns:\n        dict: Frames where exposure is set to \"Head\" by layer id.\n    \"\"\"\n\n    if layers_data is None:\n        layers_data = get_layers_data(layer_ids)\n    _layers_by_id = {\n        layer[\"layer_id\"]: layer\n        for layer in layers_data\n    }\n    layers_by_id = {\n        layer_id: _layers_by_id.get(layer_id)\n        for layer_id in layer_ids\n    }\n    tmp_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n    )\n    tmp_file.close()\n    tmp_output_path = tmp_file.name.replace(\"\\\\\", \"/\")\n    george_script_lines = [\n        \"output_path = \\\"{}\\\"\".format(tmp_output_path)\n    ]\n\n    output = {}\n    layer_id_mapping = {}\n    for layer_id, layer_data in layers_by_id.items():\n        layer_id_mapping[str(layer_id)] = layer_id\n        output[layer_id] = []\n        if not layer_data:\n            continue\n        first_frame = layer_data[\"frame_start\"]\n        last_frame = layer_data[\"frame_end\"]\n        george_script_lines.extend([\n            \"line = \\\"\\\"\",\n            \"layer_id = {}\".format(layer_id),\n            \"line = line''layer_id\",\n            \"tv_layerset layer_id\",\n            \"frame = {}\".format(first_frame),\n            \"WHILE (frame &lt;= {})\".format(last_frame),\n            \"tv_exposureinfo frame\",\n            \"exposure = result\",\n            \"IF (CMP(exposure, \\\"Head\\\") == 1)\",\n            \"line = line'|'frame\",\n            \"END\",\n            \"frame = frame + 1\",\n            \"END\",\n            \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' line\"\n        ])\n\n    execute_george_through_file(\"\\n\".join(george_script_lines), communicator)\n\n    with open(tmp_output_path, \"r\") as stream:\n        data = stream.read()\n\n    os.remove(tmp_output_path)\n\n    lines = []\n    for line in data.split(\"\\n\"):\n        line = line.strip()\n        if line:\n            lines.append(line)\n\n    for line in lines:\n        line_items = list(line.split(\"|\"))\n        layer_id = line_items.pop(0)\n        _layer_id = layer_id_mapping[layer_id]\n        output[_layer_id] = [int(frame) for frame in line_items]\n\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.get_layers_pre_post_behavior","title":"<code>get_layers_pre_post_behavior(layer_ids, communicator=None)</code>","text":"<p>Collect data about pre and post behavior of layer ids.</p> <p>Pre and Post behaviors is enumerator of possible values: - \"none\" - \"repeat\" - \"pingpong\" - \"hold\"</p> <p>Example output:</p> <pre><code>{\n    0: {\n        \"pre\": \"none\",\n        \"post\": \"repeat\"\n    }\n}\n</code></pre> <p>Returns:</p> Name Type Description <code>dict</code> <p>Key is layer id value is dictionary with \"pre\" and \"post\" keys.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def get_layers_pre_post_behavior(layer_ids, communicator=None):\n    \"\"\"Collect data about pre and post behavior of layer ids.\n\n    Pre and Post behaviors is enumerator of possible values:\n    - \"none\"\n    - \"repeat\"\n    - \"pingpong\"\n    - \"hold\"\n\n    Example output:\n    ```json\n    {\n        0: {\n            \"pre\": \"none\",\n            \"post\": \"repeat\"\n        }\n    }\n    ```\n\n    Returns:\n        dict: Key is layer id value is dictionary with \"pre\" and \"post\" keys.\n    \"\"\"\n    # Skip if is empty\n    if not layer_ids:\n        return {}\n\n    # Auto convert to list\n    if not isinstance(layer_ids, (list, set, tuple)):\n        layer_ids = [layer_ids]\n\n    # Prepare temp file\n    output_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n    )\n    output_file.close()\n\n    output_filepath = output_file.name.replace(\"\\\\\", \"/\")\n    george_script_lines = [\n        # Variable containing full path to output file\n        \"output_path = \\\"{}\\\"\".format(output_filepath),\n    ]\n    for layer_id in layer_ids:\n        george_script_lines.extend([\n            \"layer_id = {}\".format(layer_id),\n            \"tv_layerprebehavior layer_id\",\n            \"pre_beh = result\",\n            \"tv_layerpostbehavior layer_id\",\n            \"post_beh = result\",\n            \"line = layer_id'|'pre_beh'|'post_beh\",\n            \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' line\"\n        ])\n\n    george_script = \"\\n\".join(george_script_lines)\n    execute_george_through_file(george_script, communicator)\n\n    # Read data\n    with open(output_filepath, \"r\") as stream:\n        data = stream.read()\n\n    # Remove temp file\n    os.remove(output_filepath)\n\n    # Parse data\n    output = {}\n    raw_lines = data.split(\"\\n\")\n    for raw_line in raw_lines:\n        line = raw_line.strip()\n        if not line:\n            continue\n        parts = line.split(\"|\")\n        if len(parts) != 3:\n            continue\n        layer_id, pre_beh, post_beh = parts\n        output[int(layer_id)] = {\n            \"pre\": pre_beh.lower(),\n            \"post\": post_beh.lower()\n        }\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.get_scene_bg_color","title":"<code>get_scene_bg_color(communicator=None)</code>","text":"<p>Background color set on scene.</p> <p>Is important for review exporting where scene bg color is used as background.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def get_scene_bg_color(communicator=None):\n    \"\"\"Background color set on scene.\n\n    Is important for review exporting where scene bg color is used as\n    background.\n    \"\"\"\n    output_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n    )\n    output_file.close()\n    output_filepath = output_file.name.replace(\"\\\\\", \"/\")\n    george_script_lines = [\n        # Variable containing full path to output file\n        \"output_path = \\\"{}\\\"\".format(output_filepath),\n        \"tv_background\",\n        \"bg_color = result\",\n        # Write data to output file\n        \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' bg_color\"\n    ]\n\n    george_script = \"\\n\".join(george_script_lines)\n    execute_george_through_file(george_script, communicator)\n\n    with open(output_filepath, \"r\") as stream:\n        data = stream.read()\n\n    os.remove(output_filepath)\n    data = data.strip()\n    if not data:\n        return None\n    return data.split(\" \")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.get_scene_data","title":"<code>get_scene_data(communicator=None)</code>","text":"<p>Scene data of currently opened scene.</p> <p>Result contains resolution, pixel aspect, fps mark in/out with states, frame start and background color.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>Scene data collected in many ways.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def get_scene_data(communicator=None):\n    \"\"\"Scene data of currently opened scene.\n\n    Result contains resolution, pixel aspect, fps mark in/out with states,\n    frame start and background color.\n\n    Returns:\n        dict: Scene data collected in many ways.\n    \"\"\"\n    workfile_info = execute_george(\"tv_projectinfo\", communicator)\n    workfile_info_parts = workfile_info.split(\" \")\n\n    # Project frame start - not used\n    workfile_info_parts.pop(-1)\n    field_order = workfile_info_parts.pop(-1)\n    frame_rate = float(workfile_info_parts.pop(-1))\n    pixel_apsect = float(workfile_info_parts.pop(-1))\n    height = int(workfile_info_parts.pop(-1))\n    width = int(workfile_info_parts.pop(-1))\n\n    # Marks return as \"{frame - 1} {state} \", example \"0 set\".\n    result = execute_george(\"tv_markin\", communicator)\n    mark_in_frame, mark_in_state, _ = result.split(\" \")\n\n    result = execute_george(\"tv_markout\", communicator)\n    mark_out_frame, mark_out_state, _ = result.split(\" \")\n\n    start_frame = execute_george(\"tv_startframe\", communicator)\n    return {\n        \"width\": width,\n        \"height\": height,\n        \"pixel_aspect\": pixel_apsect,\n        \"fps\": frame_rate,\n        \"field_order\": field_order,\n        \"mark_in\": int(mark_in_frame),\n        \"mark_in_state\": mark_in_state,\n        \"mark_in_set\": mark_in_state == \"set\",\n        \"mark_out\": int(mark_out_frame),\n        \"mark_out_state\": mark_out_state,\n        \"mark_out_set\": mark_out_state == \"set\",\n        \"start_frame\": int(start_frame),\n        \"bg_color\": get_scene_bg_color(communicator)\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.groups_data","title":"<code>groups_data(communicator=None)</code>","text":"<p>Backwards compatible function of 'get_groups_data'.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def groups_data(communicator=None):\n    \"\"\"Backwards compatible function of 'get_groups_data'.\"\"\"\n    return get_groups_data(communicator)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.layers_data","title":"<code>layers_data(layer_ids=None, communicator=None)</code>","text":"<p>Backwards compatible function of 'get_layers_data'.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def layers_data(layer_ids=None, communicator=None):\n    \"\"\"Backwards compatible function of 'get_layers_data'.\"\"\"\n    return get_layers_data(layer_ids, communicator)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.parse_group_data","title":"<code>parse_group_data(data)</code>","text":"<p>Parse group data collected in 'get_groups_data'.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def parse_group_data(data):\n    \"\"\"Parse group data collected in 'get_groups_data'.\"\"\"\n    output = []\n    groups_raw = data.split(\"\\n\")\n    for group_raw in groups_raw:\n        group_raw = group_raw.strip()\n        if not group_raw:\n            continue\n\n        parts = group_raw.split(\"|\")\n        # Check for length and concatenate 2 last items until length match\n        # - this happens if name contain spaces\n        while len(parts) &gt; 6:\n            last_item = parts.pop(-1)\n            parts[-1] = \"|\".join([parts[-1], last_item])\n        clip_id, group_id, red, green, blue, name = parts\n\n        group = {\n            \"group_id\": int(group_id),\n            \"name\": name,\n            \"clip_id\": int(clip_id),\n            \"red\": int(red),\n            \"green\": int(green),\n            \"blue\": int(blue),\n        }\n        output.append(group)\n    return output\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/lib.html#client.ayon_tvpaint.api.lib.parse_layers_data","title":"<code>parse_layers_data(data)</code>","text":"<p>Parse layers data loaded in 'get_layers_data'.</p> Source code in <code>client/ayon_tvpaint/api/lib.py</code> <pre><code>def parse_layers_data(data):\n    \"\"\"Parse layers data loaded in 'get_layers_data'.\"\"\"\n    layers = []\n    layers_raw = data.split(\"\\n\")\n    for layer_raw in layers_raw:\n        layer_raw = layer_raw.strip()\n        if not layer_raw:\n            continue\n        (\n            layer_id, group_id, visible, position, opacity, name,\n            layer_type,\n            frame_start, frame_end, prelighttable, postlighttable,\n            selected, editable, sencil_state, is_current\n        ) = layer_raw.split(\"|\")\n        layer = {\n            \"layer_id\": int(layer_id),\n            \"group_id\": int(group_id),\n            \"visible\": visible == \"ON\",\n            \"position\": int(position),\n            # Opacity from 'tv_layerinfo' is always set to '0' so it's unusable\n            # \"opacity\": int(opacity),\n            \"name\": name,\n            \"type\": layer_type,\n            \"frame_start\": int(frame_start),\n            \"frame_end\": int(frame_end),\n            \"prelighttable\": prelighttable == \"1\",\n            \"postlighttable\": postlighttable == \"1\",\n            \"selected\": selected == \"1\",\n            \"editable\": editable == \"1\",\n            \"sencil_state\": sencil_state,\n            \"is_current\": is_current == \"1\"\n        }\n        layers.append(layer)\n    return layers\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html","title":"pipeline","text":""},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.TVPAINT_CHUNK_LENGTH","title":"<code>TVPAINT_CHUNK_LENGTH = 500</code>  <code>module-attribute</code>","text":"<p>TVPaint's Metadata</p> <p>Metadata are stored to TVPaint's workfile.</p> <p>Workfile works similar to .ini file but has few limitation. Most important limitation is that value under key has limited length. Due to this limitation each metadata section/key stores number of \"subkeys\" that are related to the section.</p> <p>Example: Metadata key <code>\"instances\"</code> may have stored value \"2\". In that case it is expected that there are also keys <code>[\"instances0\", \"instances1\"]</code>.</p> <p>Workfile data looks like:</p> <pre><code>[avalon]\ninstances0=[{{__dq__}id{__dq__}: {__dq__}ayon.create.instance{__dq__...\ninstances1=...more data...\ninstances=2\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.TVPaintHost","title":"<code>TVPaintHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>class TVPaintHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"tvpaint\"\n\n    def install(self):\n        \"\"\"Install TVPaint-specific functionality.\"\"\"\n\n        log.info(\"AYON - Installing TVPaint integration\")\n\n        # Create workdir folder if does not exist yet\n        workdir = os.getenv(\"AYON_WORKDIR\")\n        if not os.path.exists(workdir):\n            os.makedirs(workdir)\n\n        plugins_dir = os.path.join(TVPAINT_ROOT_DIR, \"plugins\")\n        publish_dir = os.path.join(plugins_dir, \"publish\")\n        load_dir = os.path.join(plugins_dir, \"load\")\n        create_dir = os.path.join(plugins_dir, \"create\")\n\n        pyblish.api.register_host(\"tvpaint\")\n        pyblish.api.register_plugin_path(publish_dir)\n        register_loader_plugin_path(load_dir)\n        register_creator_plugin_path(create_dir)\n\n        register_event_callback(\"application.launched\", self.initial_launch)\n        register_event_callback(\"application.exit\", self.application_exit)\n        register_event_callback(\n            \"workfile.open.after\",\n            self._on_workfile_open_after\n        )\n\n    def get_current_project_name(self):\n        \"\"\"\n        Returns:\n            Union[str, None]: Current project name.\n        \"\"\"\n\n        return self.get_current_context().get(\"project_name\")\n\n    def get_current_folder_path(self):\n        \"\"\"\n        Returns:\n            Union[str, None]: Current folder path.\n        \"\"\"\n\n        return self.get_current_context().get(\"folder_path\")\n\n    def get_current_task_name(self):\n        \"\"\"\n        Returns:\n            Union[str, None]: Current task name.\n        \"\"\"\n\n        return self.get_current_context().get(\"task_name\")\n\n    def get_current_context(self):\n        context = get_current_workfile_context()\n        if not context:\n            return get_global_context()\n\n        if \"project_name\" in context:\n            if \"asset_name\" in context:\n                context[\"folder_path\"] = context[\"asset_name\"]\n            return context\n        # This is legacy way how context was stored\n        return {\n            \"project_name\": context.get(\"project\"),\n            \"folder_path\": context.get(\"asset\"),\n            \"task_name\": context.get(\"task\")\n        }\n\n    # --- Create ---\n    def get_context_data(self):\n        return get_workfile_metadata(SECTION_NAME_CREATE_CONTEXT, {})\n\n    def update_context_data(self, data, changes):\n        return write_workfile_metadata(SECTION_NAME_CREATE_CONTEXT, data)\n\n    def list_instances(self):\n        \"\"\"List all created instances from current workfile.\"\"\"\n        return list_instances()\n\n    def write_instances(self, data):\n        return write_instances(data)\n\n    # --- Workfile ---\n    def open_workfile(self, filepath):\n        george_script = \"tv_LoadProject '\\\"'\\\"{}\\\"'\\\"'\".format(\n            filepath.replace(\"\\\\\", \"/\")\n        )\n        return execute_george_through_file(george_script)\n\n    def save_workfile(self, filepath=None):\n        if not filepath:\n            filepath = self.get_current_workfile()\n        context = get_global_context()\n        save_current_workfile_context(context)\n\n        # Execute george script to save workfile.\n        george_script = \"tv_SaveProject {}\".format(filepath.replace(\"\\\\\", \"/\"))\n        return execute_george(george_script)\n\n    def work_root(self, session):\n        return session[\"AYON_WORKDIR\"]\n\n    def get_current_workfile(self):\n        # TVPaint returns a '\\' character when no scene is currently opened\n        current_workfile = execute_george(\"tv_GetProjectName\")\n        if current_workfile == '\\\\':\n            return None\n        return current_workfile\n\n    def workfile_has_unsaved_changes(self):\n        return None\n\n    def get_workfile_extensions(self):\n        return [\".tvpp\"]\n\n    # --- Load ---\n    def get_containers(self):\n        return get_containers()\n\n    def initial_launch(self):\n        # Setup project context\n        # - if was used e.g. template the context might be invalid.\n        if not self.get_current_workfile():\n            return\n\n        log.info(\"Setting up context...\")\n        global_context = get_global_context()\n        project_name = global_context.get(\"project_name\")\n        if not project_name:\n            return\n\n        save_current_workfile_context(global_context)\n        # TODO fix 'set_context_settings'\n        return\n\n        folder_path = global_context.get(\"folder_path\")\n        task_name = global_context.get(\"task_name\")\n\n        if not folder_path:\n            return\n\n        folder_entity = ayon_api.get_folder_by_path(project_name, folder_path)\n        if folder_entity and task_name:\n            task_entity = ayon_api.get_task_by_name(\n                project_name,\n                folder_id=folder_entity[\"id\"],\n                task_name=task_name)\n            context_entity = task_entity\n        else:\n            log.warning(\n                \"Falling back to setting context settings using folder entity \"\n                \"because no task was found.\")\n            context_entity = folder_entity\n\n        set_context_settings(context_entity)\n\n    def application_exit(self):\n        \"\"\"Logic related to TimerManager.\n\n        Todo:\n            This should be handled out of TVPaint integration logic.\n        \"\"\"\n\n        data = get_current_project_settings()\n        stop_timer = data[\"tvpaint\"][\"stop_timer_on_application_exit\"]\n\n        if not stop_timer:\n            return\n\n        # Stop application timer.\n        webserver_url = os.environ.get(\"AYON_WEBSERVER_URL\")\n        rest_api_url = \"{}/timers_manager/stop_timer\".format(webserver_url)\n        requests.post(rest_api_url)\n\n    def _on_workfile_open_after(self):\n        # Make sure opened workfile has stored correct context\n        global_context = get_global_context()\n        save_current_workfile_context(global_context)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.TVPaintHost.application_exit","title":"<code>application_exit()</code>","text":"<p>Logic related to TimerManager.</p> Todo <p>This should be handled out of TVPaint integration logic.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def application_exit(self):\n    \"\"\"Logic related to TimerManager.\n\n    Todo:\n        This should be handled out of TVPaint integration logic.\n    \"\"\"\n\n    data = get_current_project_settings()\n    stop_timer = data[\"tvpaint\"][\"stop_timer_on_application_exit\"]\n\n    if not stop_timer:\n        return\n\n    # Stop application timer.\n    webserver_url = os.environ.get(\"AYON_WEBSERVER_URL\")\n    rest_api_url = \"{}/timers_manager/stop_timer\".format(webserver_url)\n    requests.post(rest_api_url)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.TVPaintHost.get_current_folder_path","title":"<code>get_current_folder_path()</code>","text":"<p>Returns:</p> Type Description <p>Union[str, None]: Current folder path.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_current_folder_path(self):\n    \"\"\"\n    Returns:\n        Union[str, None]: Current folder path.\n    \"\"\"\n\n    return self.get_current_context().get(\"folder_path\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.TVPaintHost.get_current_project_name","title":"<code>get_current_project_name()</code>","text":"<p>Returns:</p> Type Description <p>Union[str, None]: Current project name.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_current_project_name(self):\n    \"\"\"\n    Returns:\n        Union[str, None]: Current project name.\n    \"\"\"\n\n    return self.get_current_context().get(\"project_name\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.TVPaintHost.get_current_task_name","title":"<code>get_current_task_name()</code>","text":"<p>Returns:</p> Type Description <p>Union[str, None]: Current task name.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_current_task_name(self):\n    \"\"\"\n    Returns:\n        Union[str, None]: Current task name.\n    \"\"\"\n\n    return self.get_current_context().get(\"task_name\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.TVPaintHost.install","title":"<code>install()</code>","text":"<p>Install TVPaint-specific functionality.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install TVPaint-specific functionality.\"\"\"\n\n    log.info(\"AYON - Installing TVPaint integration\")\n\n    # Create workdir folder if does not exist yet\n    workdir = os.getenv(\"AYON_WORKDIR\")\n    if not os.path.exists(workdir):\n        os.makedirs(workdir)\n\n    plugins_dir = os.path.join(TVPAINT_ROOT_DIR, \"plugins\")\n    publish_dir = os.path.join(plugins_dir, \"publish\")\n    load_dir = os.path.join(plugins_dir, \"load\")\n    create_dir = os.path.join(plugins_dir, \"create\")\n\n    pyblish.api.register_host(\"tvpaint\")\n    pyblish.api.register_plugin_path(publish_dir)\n    register_loader_plugin_path(load_dir)\n    register_creator_plugin_path(create_dir)\n\n    register_event_callback(\"application.launched\", self.initial_launch)\n    register_event_callback(\"application.exit\", self.application_exit)\n    register_event_callback(\n        \"workfile.open.after\",\n        self._on_workfile_open_after\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.TVPaintHost.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def list_instances(self):\n    \"\"\"List all created instances from current workfile.\"\"\"\n    return list_instances()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.containerise","title":"<code>containerise(name, namespace, members, context, loader, current_containers=None)</code>","text":"<p>Add new container to metadata.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Container name.</p> required <code>namespace</code> <code>str</code> <p>Container namespace.</p> required <code>members</code> <code>list</code> <p>List of members that were loaded and belongs to the container (layer names).</p> required <code>current_containers</code> <code>list</code> <p>Preloaded containers. Should be used only on update/switch when containers were modified during the process.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Container data stored to workfile metadata.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def containerise(\n    name, namespace, members, context, loader, current_containers=None\n):\n    \"\"\"Add new container to metadata.\n\n    Args:\n        name (str): Container name.\n        namespace (str): Container namespace.\n        members (list): List of members that were loaded and belongs\n            to the container (layer names).\n        current_containers (list): Preloaded containers. Should be used only\n            on update/switch when containers were modified during the process.\n\n    Returns:\n        dict: Container data stored to workfile metadata.\n    \"\"\"\n\n    container_data = {\n        \"members\": members,\n        \"name\": name,\n        \"namespace\": namespace,\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"]\n    }\n    if current_containers is None:\n        current_containers = get_containers()\n\n    # Add container to containers list\n    current_containers.append(container_data)\n\n    # Store data to metadata\n    write_workfile_metadata(SECTION_NAME_CONTAINERS, current_containers)\n\n    return container_data\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.get_current_workfile_context","title":"<code>get_current_workfile_context()</code>","text":"<p>Return context in which was workfile saved.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_current_workfile_context():\n    \"\"\"Return context in which was workfile saved.\"\"\"\n    return get_workfile_metadata(SECTION_NAME_CONTEXT, {})\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.get_workfile_metadata","title":"<code>get_workfile_metadata(metadata_key, default=None)</code>","text":"<p>Read and parse metadata for specific key from current project workfile.</p> <p>Pipeline use function to store loaded and created instances within keys stored in <code>SECTION_NAME_INSTANCES</code> and <code>SECTION_NAME_CONTAINERS</code> constants.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_key</code> <code>str</code> <p>Key defying which key should read. It is expected value contain json serializable string.</p> required Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_workfile_metadata(metadata_key, default=None):\n    \"\"\"Read and parse metadata for specific key from current project workfile.\n\n    Pipeline use function to store loaded and created instances within keys\n    stored in `SECTION_NAME_INSTANCES` and `SECTION_NAME_CONTAINERS`\n    constants.\n\n    Args:\n        metadata_key (str): Key defying which key should read. It is expected\n            value contain json serializable string.\n    \"\"\"\n    if default is None:\n        default = []\n\n    json_string = get_workfile_metadata_string(metadata_key)\n    if json_string:\n        try:\n            return json.loads(json_string)\n        except json.decoder.JSONDecodeError:\n            # TODO remove when backwards compatibility of storing metadata\n            # will be removed\n            print((\n                \"Fixed invalid metadata in workfile.\"\n                \" Not serializable string was: {}\"\n            ).format(json_string))\n            write_workfile_metadata(metadata_key, default)\n    return default\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.get_workfile_metadata_string","title":"<code>get_workfile_metadata_string(metadata_key)</code>","text":"<p>Read metadata for specific key from current project workfile.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_workfile_metadata_string(metadata_key):\n    \"\"\"Read metadata for specific key from current project workfile.\"\"\"\n    result = get_workfile_metadata_string_for_keys([metadata_key])\n    if not result:\n        return None\n\n    stripped_result = result.strip()\n    if not stripped_result:\n        return None\n\n    # NOTE Backwards compatibility when metadata key did not store range of key\n    #   indexes but the value itself\n    # NOTE We don't have to care about negative values with `isdecimal` check\n    if not stripped_result.isdecimal():\n        metadata_string = result\n    else:\n        keys = []\n        for idx in range(int(stripped_result)):\n            keys.append(\"{}{}\".format(metadata_key, idx))\n        metadata_string = get_workfile_metadata_string_for_keys(keys)\n\n    # Replace quotes plaholders with their values\n    metadata_string = (\n        metadata_string\n        .replace(\"{__sq__}\", \"'\")\n        .replace(\"{__dq__}\", \"\\\"\")\n    )\n    return metadata_string\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.get_workfile_metadata_string_for_keys","title":"<code>get_workfile_metadata_string_for_keys(metadata_keys)</code>","text":"<p>Read metadata for specific keys from current project workfile.</p> <p>All values from entered keys are stored to single string without separator.</p> <p>Function is designed to help get all values for one metadata key at once. So order of passed keys matteres.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_keys</code> <code>(list, str)</code> <p>Metadata keys for which data should be retrieved. Order of keys matters! It is possible to enter only single key as string.</p> required Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def get_workfile_metadata_string_for_keys(metadata_keys):\n    \"\"\"Read metadata for specific keys from current project workfile.\n\n    All values from entered keys are stored to single string without separator.\n\n    Function is designed to help get all values for one metadata key at once.\n    So order of passed keys matteres.\n\n    Args:\n        metadata_keys (list, str): Metadata keys for which data should be\n            retrieved. Order of keys matters! It is possible to enter only\n            single key as string.\n    \"\"\"\n    # Add ability to pass only single key\n    if isinstance(metadata_keys, str):\n        metadata_keys = [metadata_keys]\n\n    output_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n    )\n    output_file.close()\n    output_filepath = output_file.name.replace(\"\\\\\", \"/\")\n\n    george_script_parts = []\n    george_script_parts.append(\n        \"output_path = \\\"{}\\\"\".format(output_filepath)\n    )\n    # Store data for each index of metadata key\n    for metadata_key in metadata_keys:\n        george_script_parts.append(\n            \"tv_readprojectstring \\\"{}\\\" \\\"{}\\\" \\\"\\\"\".format(\n                METADATA_SECTION, metadata_key\n            )\n        )\n        george_script_parts.append(\n            \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' result\"\n        )\n\n    # Execute the script\n    george_script = \"\\n\".join(george_script_parts)\n    execute_george_through_file(george_script)\n\n    # Load data from temp file\n    with open(output_filepath, \"r\") as stream:\n        file_content = stream.read()\n\n    # Remove `\\n` from content\n    output_string = file_content.replace(\"\\n\", \"\")\n\n    # Delete temp file\n    os.remove(output_filepath)\n\n    return output_string\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.list_instances","title":"<code>list_instances()</code>","text":"<p>List all created instances from current workfile.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def list_instances():\n    \"\"\"List all created instances from current workfile.\"\"\"\n    return get_workfile_metadata(SECTION_NAME_INSTANCES)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.save_current_workfile_context","title":"<code>save_current_workfile_context(context)</code>","text":"<p>Save context which was used to create a workfile.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def save_current_workfile_context(context):\n    \"\"\"Save context which was used to create a workfile.\"\"\"\n    return write_workfile_metadata(SECTION_NAME_CONTEXT, context)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.set_context_settings","title":"<code>set_context_settings(context_entity)</code>","text":"<p>Set workfile settings by folder entity attributes.</p> <p>Change fps, resolution and frame start/end.</p> <p>Parameters:</p> Name Type Description Default <code>context_entity</code> <code>dict[str, Any]</code> <p>Task or folder entity.</p> required Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def set_context_settings(context_entity):\n    \"\"\"Set workfile settings by folder entity attributes.\n\n    Change fps, resolution and frame start/end.\n\n    Args:\n        context_entity (dict[str, Any]): Task or folder entity.\n\n    \"\"\"\n    # TODO We should fix these issues:\n    # - do not use 'tv_resizepage' or find out why it removes layers\n    # - mark in/out should respect existing mark in value if is set\n    if not context_entity:\n        return\n\n    attributes = context_entity[\"attrib\"]\n\n    width = attributes.get(\"resolutionWidth\")\n    height = attributes.get(\"resolutionHeight\")\n    if width is None or height is None:\n        print(\"Resolution was not found!\")\n    else:\n        execute_george(\n            \"tv_resizepage {} {} 0\".format(width, height)\n        )\n\n    framerate = attributes.get(\"fps\")\n\n    if framerate is not None:\n        execute_george(\n            \"tv_framerate {} \\\"timestretch\\\"\".format(framerate)\n        )\n    else:\n        print(\"Framerate was not found!\")\n\n    frame_start = attributes.get(\"frameStart\")\n    frame_end = attributes.get(\"frameEnd\")\n\n    if frame_start is None or frame_end is None:\n        print(\"Frame range was not found!\")\n        return\n\n    handle_start = attributes.get(\"handleStart\") or 0\n    handle_end = attributes.get(\"handleEnd\") or 0\n\n    # Always start from 0 Mark In and set only Mark Out\n    mark_in = 0\n    mark_out = mark_in + (frame_end - frame_start) + handle_start + handle_end\n\n    execute_george(\"tv_markin {} set\".format(mark_in))\n    execute_george(\"tv_markout {} set\".format(mark_out))\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.split_metadata_string","title":"<code>split_metadata_string(text, chunk_length=None)</code>","text":"<p>Split string by length.</p> <p>Split text to chunks by entered length. Example:     <code>python     text = \"ABCDEFGHIJKLM\"     result = split_metadata_string(text, 3)     print(result)     &gt;&gt;&gt; ['ABC', 'DEF', 'GHI', 'JKL']</code></p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text that will be split into chunks.</p> required <code>chunk_length</code> <code>int</code> <p>Single chunk size. Default chunk_length is set to global variable <code>TVPAINT_CHUNK_LENGTH</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <p>List of strings with at least one item.</p> Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def split_metadata_string(text, chunk_length=None):\n    \"\"\"Split string by length.\n\n    Split text to chunks by entered length.\n    Example:\n        ```python\n        text = \"ABCDEFGHIJKLM\"\n        result = split_metadata_string(text, 3)\n        print(result)\n        &gt;&gt;&gt; ['ABC', 'DEF', 'GHI', 'JKL']\n        ```\n\n    Args:\n        text (str): Text that will be split into chunks.\n        chunk_length (int): Single chunk size. Default chunk_length is\n            set to global variable `TVPAINT_CHUNK_LENGTH`.\n\n    Returns:\n        list: List of strings with at least one item.\n    \"\"\"\n    if chunk_length is None:\n        chunk_length = TVPAINT_CHUNK_LENGTH\n    chunks = []\n    for idx in range(chunk_length, len(text) + chunk_length, chunk_length):\n        start_idx = idx - chunk_length\n        chunks.append(text[start_idx:idx])\n    return chunks\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/pipeline.html#client.ayon_tvpaint.api.pipeline.write_workfile_metadata","title":"<code>write_workfile_metadata(metadata_key, value)</code>","text":"<p>Write metadata for specific key into current project workfile.</p> <p>George script has specific way how to work with quotes which should be solved automatically with this function.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_key</code> <code>str</code> <p>Key defying under which key value will be stored.</p> required <code>value</code> <code>(dict, list, str)</code> <p>Data to store they must be json serializable.</p> required Source code in <code>client/ayon_tvpaint/api/pipeline.py</code> <pre><code>def write_workfile_metadata(metadata_key, value):\n    \"\"\"Write metadata for specific key into current project workfile.\n\n    George script has specific way how to work with quotes which should be\n    solved automatically with this function.\n\n    Args:\n        metadata_key (str): Key defying under which key value will be stored.\n        value (dict,list,str): Data to store they must be json serializable.\n    \"\"\"\n    if isinstance(value, (dict, list)):\n        value = json.dumps(value)\n\n    if not value:\n        value = \"\"\n\n    # Handle quotes in dumped json string\n    # - replace single and double quotes with placeholders\n    value = (\n        value\n        .replace(\"'\", \"{__sq__}\")\n        .replace(\"\\\"\", \"{__dq__}\")\n    )\n    chunks = split_metadata_string(value)\n    chunks_len = len(chunks)\n\n    write_template = \"tv_writeprojectstring \\\"{}\\\" \\\"{}\\\" \\\"{}\\\"\"\n    george_script_parts = []\n    # Add information about chunks length to metadata key itself\n    george_script_parts.append(\n        write_template.format(METADATA_SECTION, metadata_key, chunks_len)\n    )\n    # Add chunk values to indexed metadata keys\n    for idx, chunk_value in enumerate(chunks):\n        sub_key = \"{}{}\".format(metadata_key, idx)\n        george_script_parts.append(\n            write_template.format(METADATA_SECTION, sub_key, chunk_value)\n        )\n\n    george_script = \"\\n\".join(george_script_parts)\n\n    return execute_george_through_file(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_tvpaint/api/plugin.html#client.ayon_tvpaint.api.plugin.Loader","title":"<code>Loader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> Source code in <code>client/ayon_tvpaint/api/plugin.py</code> <pre><code>class Loader(LoaderPlugin):\n    hosts = [\"tvpaint\"]\n    settings_category = \"tvpaint\"\n\n    @staticmethod\n    def get_members_from_container(container):\n        if \"members\" not in container and \"objectName\" in container:\n            # Backwards compatibility\n            layer_ids_str = container.get(\"objectName\")\n            return [\n                int(layer_id) for layer_id in layer_ids_str.split(\"|\")\n            ]\n        return container[\"members\"]\n\n    def get_unique_layer_name(self, namespace, name):\n        \"\"\"Layer name with counter as suffix.\n\n        Find higher 3 digit suffix from all layer names in scene matching regex\n        `{namespace}_{name}_{suffix}`. Higher 3 digit suffix is used\n        as base for next number if scene does not contain layer matching regex\n        `0` is used ase base.\n\n        Args:\n            namespace (str): Usually folder name.\n            name (str): Name of loaded product.\n\n        Returns:\n            str: `{namespace}_{name}_{higher suffix + 1}`\n        \"\"\"\n        layer_name_base = \"{}_{}\".format(namespace, name)\n\n        counter_regex = re.compile(r\"_(\\d{3})$\")\n\n        higher_counter = 0\n        for layer in get_layers_data():\n            layer_name = layer[\"name\"]\n            if not layer_name.startswith(layer_name_base):\n                continue\n            number_subpart = layer_name[len(layer_name_base):]\n            groups = counter_regex.findall(number_subpart)\n            if len(groups) != 1:\n                continue\n\n            counter = int(groups[0])\n            if counter &gt; higher_counter:\n                higher_counter = counter\n                continue\n\n        return \"{}_{:0&gt;3d}\".format(layer_name_base, higher_counter + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/api/plugin.html#client.ayon_tvpaint.api.plugin.Loader.get_unique_layer_name","title":"<code>get_unique_layer_name(namespace, name)</code>","text":"<p>Layer name with counter as suffix.</p> <p>Find higher 3 digit suffix from all layer names in scene matching regex <code>{namespace}_{name}_{suffix}</code>. Higher 3 digit suffix is used as base for next number if scene does not contain layer matching regex <code>0</code> is used ase base.</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>Usually folder name.</p> required <code>name</code> <code>str</code> <p>Name of loaded product.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p><code>{namespace}_{name}_{higher suffix + 1}</code></p> Source code in <code>client/ayon_tvpaint/api/plugin.py</code> <pre><code>def get_unique_layer_name(self, namespace, name):\n    \"\"\"Layer name with counter as suffix.\n\n    Find higher 3 digit suffix from all layer names in scene matching regex\n    `{namespace}_{name}_{suffix}`. Higher 3 digit suffix is used\n    as base for next number if scene does not contain layer matching regex\n    `0` is used ase base.\n\n    Args:\n        namespace (str): Usually folder name.\n        name (str): Name of loaded product.\n\n    Returns:\n        str: `{namespace}_{name}_{higher suffix + 1}`\n    \"\"\"\n    layer_name_base = \"{}_{}\".format(namespace, name)\n\n    counter_regex = re.compile(r\"_(\\d{3})$\")\n\n    higher_counter = 0\n    for layer in get_layers_data():\n        layer_name = layer[\"name\"]\n        if not layer_name.startswith(layer_name_base):\n            continue\n        number_subpart = layer_name[len(layer_name_base):]\n        groups = counter_regex.findall(number_subpart)\n        if len(groups) != 1:\n            continue\n\n        counter = int(groups[0])\n        if counter &gt; higher_counter:\n            higher_counter = counter\n            continue\n\n    return \"{}_{:0&gt;3d}\".format(layer_name_base, higher_counter + 1)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_tvpaint/hooks/pre_launch_args.html","title":"pre_launch_args","text":""},{"location":"autoapi/client/ayon_tvpaint/hooks/pre_launch_args.html#client.ayon_tvpaint.hooks.pre_launch_args.TvpaintPrelaunchHook","title":"<code>TvpaintPrelaunchHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Launch arguments preparation.</p> <p>Hook add python executable and script path to tvpaint implementation before tvpaint executable and add last workfile path to launch arguments.</p> <p>Existence of last workfile is checked. If workfile does not exists tries to copy templated workfile from predefined path.</p> Source code in <code>client/ayon_tvpaint/hooks/pre_launch_args.py</code> <pre><code>class TvpaintPrelaunchHook(PreLaunchHook):\n    \"\"\"Launch arguments preparation.\n\n    Hook add python executable and script path to tvpaint implementation before\n    tvpaint executable and add last workfile path to launch arguments.\n\n    Existence of last workfile is checked. If workfile does not exists tries\n    to copy templated workfile from predefined path.\n    \"\"\"\n    app_groups = {\"tvpaint\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Pop tvpaint executable\n        executable_path = self.launch_context.launch_args.pop(0)\n\n        # Pop rest of launch arguments - There should not be other arguments!\n        remainders = []\n        while self.launch_context.launch_args:\n            remainders.append(self.launch_context.launch_args.pop(0))\n\n        new_launch_args = get_ayon_launcher_args(\n            \"run\", self.launch_script_path(), executable_path\n        )\n\n        # Append as whole list as these areguments should not be separated\n        self.launch_context.launch_args.append(new_launch_args)\n\n        if remainders:\n            self.log.warning((\n                \"There are unexpected launch arguments in TVPaint launch. {}\"\n            ).format(str(remainders)))\n            self.launch_context.launch_args.extend(remainders)\n\n    def launch_script_path(self):\n        from ayon_tvpaint import get_launch_script_path\n\n        return get_launch_script_path()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/create/convert_legacy.html","title":"convert_legacy","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/create/convert_legacy.html#client.ayon_tvpaint.plugins.create.convert_legacy.TVPaintLegacyConverted","title":"<code>TVPaintLegacyConverted</code>","text":"<p>               Bases: <code>ProductConvertorPlugin</code></p> <p>Conversion of legacy instances in scene to new creators.</p> <p>This convertor handles only instances created by core creators.</p> <p>All instances that would be created using auto-creators are removed as at the moment of finding them would there already be existing instances.</p> Source code in <code>client/ayon_tvpaint/plugins/create/convert_legacy.py</code> <pre><code>class TVPaintLegacyConverted(ProductConvertorPlugin):\n    \"\"\"Conversion of legacy instances in scene to new creators.\n\n    This convertor handles only instances created by core creators.\n\n    All instances that would be created using auto-creators are removed as at\n    the moment of finding them would there already be existing instances.\n    \"\"\"\n\n    identifier = \"tvpaint.legacy.converter\"\n\n    def find_instances(self):\n        instances_by_identifier = cache_and_get_instances(\n            self, SHARED_DATA_KEY, self.host.list_instances\n        )\n        if instances_by_identifier[None]:\n            self.add_convertor_item(\"Convert legacy instances\")\n\n    def convert(self):\n        current_instances = self.host.list_instances()\n        to_convert = collections.defaultdict(list)\n        converted = False\n        for instance in current_instances:\n            if instance.get(\"creator_identifier\") is not None:\n                continue\n            converted = True\n\n            family = instance.get(\"family\")\n            if family in (\n                \"renderLayer\",\n                \"renderPass\",\n                \"renderScene\",\n                \"review\",\n                \"workfile\",\n            ):\n                to_convert[family].append(instance)\n            else:\n                instance[\"keep\"] = False\n\n        # Skip if nothing was changed\n        if not converted:\n            self.remove_convertor_item()\n            return\n\n        self._convert_render_layers(\n            to_convert[\"renderLayer\"], current_instances)\n        self._convert_render_passes(\n            to_convert[\"renderPass\"], current_instances)\n        self._convert_render_scenes(\n            to_convert[\"renderScene\"], current_instances)\n        self._convert_workfiles(\n            to_convert[\"workfile\"], current_instances)\n        self._convert_reviews(\n            to_convert[\"review\"], current_instances)\n\n        new_instances = [\n            instance\n            for instance in current_instances\n            if instance.get(\"keep\") is not False\n        ]\n        self.host.write_instances(new_instances)\n        # remove legacy item if all is fine\n        self.remove_convertor_item()\n\n    def _convert_render_layers(self, render_layers, current_instances):\n        if not render_layers:\n            return\n\n        # Look for possible existing render layers in scene\n        render_layers_by_group_id = {}\n        for instance in current_instances:\n            if instance.get(\"creator_identifier\") == \"render.layer\":\n                group_id = instance[\"creator_identifier\"][\"group_id\"]\n                render_layers_by_group_id[group_id] = instance\n\n        groups_by_id = {\n            group[\"group_id\"]: group\n            for group in get_groups_data()\n        }\n        for render_layer in render_layers:\n            group_id = render_layer.pop(\"group_id\")\n            # Just remove legacy instance if group is already occupied\n            if group_id in render_layers_by_group_id:\n                render_layer[\"keep\"] = False\n                continue\n            # Add identifier\n            render_layer[\"creator_identifier\"] = \"render.layer\"\n            # Change 'uuid' to 'instance_id'\n            render_layer[\"instance_id\"] = render_layer.pop(\"uuid\")\n            # Fill creator attributes\n            render_layer[\"creator_attributes\"] = {\n                \"group_id\": group_id\n            }\n            render_layer[\"productType\"] = \"render\"\n            group = groups_by_id[group_id]\n            # Use group name for variant\n            group[\"variant\"] = group[\"name\"]\n\n    def _convert_render_passes(self, render_passes, current_instances):\n        if not render_passes:\n            return\n\n        # Render passes must have available render layers so we look for render\n        #   layers first\n        # - '_convert_render_layers' must be called before this method\n        render_layers_by_group_id = {}\n        for instance in current_instances:\n            if instance.get(\"creator_identifier\") == \"render.layer\":\n                group_id = instance[\"creator_attributes\"][\"group_id\"]\n                render_layers_by_group_id[group_id] = instance\n\n        for render_pass in render_passes:\n            group_id = render_pass.pop(\"group_id\")\n            render_layer = render_layers_by_group_id.get(group_id)\n            if not render_layer:\n                render_pass[\"keep\"] = False\n                continue\n\n            render_pass[\"creator_identifier\"] = \"render.pass\"\n            render_pass[\"instance_id\"] = render_pass.pop(\"uuid\")\n            render_pass[\"productType\"] = \"render\"\n\n            render_pass[\"creator_attributes\"] = {\n                \"render_layer_instance_id\": render_layer[\"instance_id\"]\n            }\n            render_pass[\"variant\"] = render_pass.pop(\"pass\")\n            render_pass.pop(\"renderlayer\")\n\n    # Rest of instances are just marked for deletion\n    def _convert_render_scenes(self, render_scenes, current_instances):\n        for render_scene in render_scenes:\n            render_scene[\"keep\"] = False\n\n    def _convert_workfiles(self, workfiles, current_instances):\n        for render_scene in workfiles:\n            render_scene[\"keep\"] = False\n\n    def _convert_reviews(self, reviews, current_instances):\n        for render_scene in reviews:\n            render_scene[\"keep\"] = False\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/create/create_render.html","title":"create_render","text":"<p>Render Layer and Passes creators.</p> <p>Render layer is main part which is represented by group in TVPaint. All TVPaint layers marked with that group color are part of the render layer. To be more specific about some parts of layer it is possible to create sub-sets of layer which are named passes. Render pass consist of layers in same color group as render layer but define more specific part.</p> <p>For example render layer could be 'Bob' which consist of 5 TVPaint layers. - Bob has 'head' which consist of 2 TVPaint layers -&gt; Render pass 'head' - Bob has 'body' which consist of 1 TVPaint layer -&gt; Render pass 'body' - Bob has 'arm' which consist of 1 TVPaint layer -&gt; Render pass 'arm' - Last layer does not belong to render pass at all</p> <p>Bob will be rendered as 'beauty' of bob (all visible layers in group). His head will be rendered too but without any other parts. The same for body and arm.</p> <p>What is this good for? Compositing has more power how the renders are used. Can do transforms on each render pass without need to modify a re-render them using TVPaint.</p> <p>The workflow may hit issues when there are used other blending modes than default 'color' blend more. In that case it is not recommended to use this workflow at all as other blend modes may affect all layers in clip which can't be done.</p> <p>There is special case for simple publishing of scene which is called 'render.scene'. That will use all visible layers and render them as one big sequence.</p> Todos <p>Add option to extract marked layers and passes as json output format for     AfterEffects.</p>"},{"location":"autoapi/client/ayon_tvpaint/plugins/create/create_render.html#client.ayon_tvpaint.plugins.create.create_render.CreateRenderlayer","title":"<code>CreateRenderlayer</code>","text":"<p>               Bases: <code>TVPaintCreator</code></p> <p>Mark layer group as Render layer instance.</p> <p>All TVPaint layers in the scene with the color group id are rendered in the beauty pass. To create sub passes use Render Layer creator which is dependent on existence of render layer instance.</p> Source code in <code>client/ayon_tvpaint/plugins/create/create_render.py</code> <pre><code>class CreateRenderlayer(TVPaintCreator):\n    \"\"\"Mark layer group as Render layer instance.\n\n    All TVPaint layers in the scene with the color group id are rendered in the\n    beauty pass. To create sub passes use Render Layer creator which is\n    dependent on existence of render layer instance.\n    \"\"\"\n\n    label = \"Render Layer\"\n    product_type = \"render\"\n    product_template_product_type = \"renderLayer\"\n    identifier = \"render.layer\"\n    icon = \"fa5.images\"\n\n    # George script to change color group\n    rename_script_template = (\n        \"tv_layercolor \\\"setcolor\\\"\"\n        \" {clip_id} {group_id} {r} {g} {b} \\\"{name}\\\"\"\n    )\n    # Order to be executed before Render Pass creator\n    order = 90\n    description = \"Mark TVPaint color group as one Render Layer.\"\n    detailed_description = RENDER_LAYER_DETAILED_DESCRIPTIONS\n\n    # Settings\n    # - Default render pass name for beauty\n    default_pass_name = \"beauty\"\n    # - Mark by default instance for review\n    mark_for_review = True\n\n    def apply_settings(self, project_settings):\n        plugin_settings = (\n            project_settings[\"tvpaint\"][\"create\"][\"create_render_layer\"]\n        )\n        self.default_variant = plugin_settings[\"default_variant\"]\n        self.default_variants = plugin_settings[\"default_variants\"]\n        self.default_pass_name = plugin_settings[\"default_pass_name\"]\n        self.mark_for_review = plugin_settings[\"mark_for_review\"]\n\n    def get_dynamic_data(\n        self,\n        project_name,\n        folder_entity,\n        task_entity,\n        variant,\n        host_name,\n        instance\n    ):\n        dynamic_data = super().get_dynamic_data(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name,\n            instance\n        )\n        dynamic_data[\"renderpass\"] = self.default_pass_name\n        dynamic_data[\"renderlayer\"] = variant\n        return dynamic_data\n\n    def _get_selected_group_ids(self):\n        return {\n            layer[\"group_id\"]\n            for layer in get_layers_data()\n            if layer[\"selected\"]\n        }\n\n    def create(self, product_name, instance_data, pre_create_data):\n        self.log.debug(\"Query data from workfile.\")\n\n        group_name = instance_data[\"variant\"]\n        group_id = pre_create_data.get(\"group_id\")\n        # This creator should run only on one group\n        if group_id is None or group_id == -1:\n            selected_groups = self._get_selected_group_ids()\n            selected_groups.discard(0)\n            if len(selected_groups) &gt; 1:\n                raise CreatorError(\"You have selected more than one group\")\n\n            if len(selected_groups) == 0:\n                raise CreatorError(\"You don't have selected any group\")\n            group_id = tuple(selected_groups)[0]\n\n        self.log.debug(\"Querying groups data from workfile.\")\n        groups_data = get_groups_data()\n        group_item = None\n        for group_data in groups_data:\n            if group_data[\"group_id\"] == group_id:\n                group_item = group_data\n\n        for instance in self.create_context.instances:\n            if (\n                instance.creator_identifier == self.identifier\n                and instance[\"creator_attributes\"][\"group_id\"] == group_id\n            ):\n                raise CreatorError((\n                    f\"Group \\\"{group_item.get('name')}\\\" is already used\"\n                    f\" by another render layer \\\"{instance['productName']}\\\"\"\n                ))\n\n        self.log.debug(f\"Selected group id is \\\"{group_id}\\\".\")\n        if \"creator_attributes\" not in instance_data:\n            instance_data[\"creator_attributes\"] = {}\n        creator_attributes = instance_data[\"creator_attributes\"]\n        mark_for_review = pre_create_data.get(\"mark_for_review\")\n        if mark_for_review is None:\n            mark_for_review = self.mark_for_review\n        creator_attributes[\"group_id\"] = group_id\n        creator_attributes[\"mark_for_review\"] = mark_for_review\n\n        self.log.info(f\"Product name is {product_name}\")\n        new_instance = CreatedInstance(\n            self.product_type,\n            product_name,\n            instance_data,\n            self\n        )\n        self._store_new_instance(new_instance)\n\n        if not group_id or group_item[\"name\"] == group_name:\n            return new_instance\n\n        self.log.debug(\"Changing name of the group.\")\n        # Rename TVPaint group (keep color same)\n        # - groups can't contain spaces\n        rename_script = self.rename_script_template.format(\n            clip_id=group_item[\"clip_id\"],\n            group_id=group_item[\"group_id\"],\n            r=group_item[\"red\"],\n            g=group_item[\"green\"],\n            b=group_item[\"blue\"],\n            name=group_name\n        )\n        execute_george_through_file(rename_script)\n\n        self.log.info((\n            f\"Name of group with index {group_id}\"\n            f\" was changed to \\\"{group_name}\\\".\"\n        ))\n        return new_instance\n\n    def _get_groups_enum(self):\n        groups_enum = []\n        empty_groups = []\n        for group in get_groups_data():\n            group_name = group[\"name\"]\n            item = {\n                \"label\": group_name,\n                \"value\": group[\"group_id\"]\n            }\n            # TVPaint have defined how many color groups is available, but\n            #   the count is not consistent across versions. It is not possible\n            #   to know how many groups there is.\n            #\n            if group_name and group_name != \"0\":\n                if empty_groups:\n                    groups_enum.extend(empty_groups)\n                    empty_groups = []\n                groups_enum.append(item)\n            else:\n                empty_groups.append(item)\n        return groups_enum\n\n    def get_pre_create_attr_defs(self):\n        groups_enum = self._get_groups_enum()\n        groups_enum.insert(0, {\"label\": \"&lt;Use selection&gt;\", \"value\": -1})\n\n        return [\n            EnumDef(\n                \"group_id\",\n                label=\"Group\",\n                items=groups_enum\n            ),\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\",\n                default=self.mark_for_review\n            )\n        ]\n\n    def get_instance_attr_defs(self):\n        groups_enum = self._get_groups_enum()\n        return [\n            EnumDef(\n                \"group_id\",\n                label=\"Group\",\n                items=groups_enum\n            ),\n            BoolDef(\n                \"mark_for_review\",\n                label=\"Review\",\n                default=self.mark_for_review\n            )\n        ]\n\n    def update_instances(self, update_list):\n        self._update_color_groups()\n        self._update_renderpass_groups()\n\n        super().update_instances(update_list)\n\n    def _update_color_groups(self):\n        render_layer_instances = []\n        for instance in self.create_context.instances:\n            if instance.creator_identifier == self.identifier:\n                render_layer_instances.append(instance)\n\n        if not render_layer_instances:\n            return\n\n        groups_by_id = {\n            group[\"group_id\"]: group\n            for group in get_groups_data()\n        }\n        grg_script_lines = []\n        for instance in render_layer_instances:\n            group_id = instance[\"creator_attributes\"][\"group_id\"]\n            variant = instance[\"variant\"]\n            group = groups_by_id[group_id]\n            if group[\"name\"] == variant:\n                continue\n\n            grg_script_lines.append(self.rename_script_template.format(\n                clip_id=group[\"clip_id\"],\n                group_id=group[\"group_id\"],\n                r=group[\"red\"],\n                g=group[\"green\"],\n                b=group[\"blue\"],\n                name=variant\n            ))\n\n        if grg_script_lines:\n            execute_george_through_file(\"\\n\".join(grg_script_lines))\n\n    def _update_renderpass_groups(self):\n        render_layer_instances = {}\n        render_pass_instances = collections.defaultdict(list)\n\n        for instance in self.create_context.instances:\n            if instance.creator_identifier == CreateRenderPass.identifier:\n                render_layer_id = (\n                    instance[\"creator_attributes\"][\"render_layer_instance_id\"]\n                )\n                render_pass_instances[render_layer_id].append(instance)\n            elif instance.creator_identifier == self.identifier:\n                render_layer_instances[instance.id] = instance\n\n        if not render_pass_instances or not render_layer_instances:\n            return\n\n        layers_data = get_layers_data()\n        layers_by_name = collections.defaultdict(list)\n        for layer in layers_data:\n            layers_by_name[layer[\"name\"]].append(layer)\n\n        george_lines = []\n        for render_layer_id, instances in render_pass_instances.items():\n            render_layer_inst = render_layer_instances.get(render_layer_id)\n            if render_layer_inst is None:\n                continue\n            group_id = render_layer_inst[\"creator_attributes\"][\"group_id\"]\n            layer_names = set()\n            for instance in instances:\n                layer_names |= set(instance[\"layer_names\"])\n\n            for layer_name in layer_names:\n                george_lines.extend(\n                    f\"tv_layercolor \\\"set\\\" {layer['layer_id']} {group_id}\"\n                    for layer in layers_by_name[layer_name]\n                    if layer[\"group_id\"] != group_id\n                )\n        if george_lines:\n            execute_george_through_file(\"\\n\".join(george_lines))\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/create/create_render.html#client.ayon_tvpaint.plugins.create.create_render.TVPaintAutoDetectRenderCreator","title":"<code>TVPaintAutoDetectRenderCreator</code>","text":"<p>               Bases: <code>TVPaintCreator</code></p> <p>Create Render Layer and Render Pass instances based on scene data.</p> <p>This is auto-detection creator which can be triggered by user to create instances based on information in scene. Each used color group in scene will be created as Render Layer where group name is used as variant and each TVPaint layer as Render Pass where layer name is used as variant.</p> <p>Never will have any instances, all instances belong to different creators.</p> Source code in <code>client/ayon_tvpaint/plugins/create/create_render.py</code> <pre><code>class TVPaintAutoDetectRenderCreator(TVPaintCreator):\n    \"\"\"Create Render Layer and Render Pass instances based on scene data.\n\n    This is auto-detection creator which can be triggered by user to create\n    instances based on information in scene. Each used color group in scene\n    will be created as Render Layer where group name is used as variant and\n    each TVPaint layer as Render Pass where layer name is used as variant.\n\n    Never will have any instances, all instances belong to different creators.\n    \"\"\"\n\n    product_type = \"render\"\n    label = \"Render Layer/Passes\"\n    identifier = \"render.auto.detect.creator\"\n    order = CreateRenderPass.order + 10\n    description = (\n        \"Create Render Layers and Render Passes based on scene setup\"\n    )\n    detailed_description = AUTODETECT_RENDER_DETAILED_DESCRIPTION\n\n    # Settings\n    enabled = False\n    allow_group_rename = True\n    group_name_template = \"L{group_index}\"\n    group_idx_offset = 10\n    group_idx_padding = 3\n\n    def apply_settings(self, project_settings):\n        plugin_settings = (\n            project_settings\n            [\"tvpaint\"]\n            [\"create\"]\n            [\"auto_detect_render\"]\n        )\n        self.enabled = plugin_settings.get(\"enabled\", False)\n        self.allow_group_rename = plugin_settings[\"allow_group_rename\"]\n        self.group_name_template = plugin_settings[\"group_name_template\"]\n        self.group_idx_offset = plugin_settings[\"group_idx_offset\"]\n        self.group_idx_padding = plugin_settings[\"group_idx_padding\"]\n\n    def _rename_groups(\n        self,\n        groups_order: list[int],\n        scene_groups: list[dict[str, Any]]\n    ):\n        new_group_name_by_id: dict[int, str] = {}\n        groups_by_id: dict[int, dict[str, Any]] = {\n            group[\"group_id\"]: group\n            for group in scene_groups\n        }\n        # Count only renamed groups\n        for idx, group_id in enumerate(groups_order):\n            group_index_value: str = (\n                \"{{:0&gt;{}}}\"\n                .format(self.group_idx_padding)\n                .format((idx + 1) * self.group_idx_offset)\n            )\n            group_name_fill_values: dict[str, str] = {\n                \"groupIdx\": group_index_value,\n                \"groupidx\": group_index_value,\n                \"group_idx\": group_index_value,\n                \"group_index\": group_index_value,\n            }\n\n            group_name: str = self.group_name_template.format(\n                **group_name_fill_values\n            )\n            group: dict[str, Any] = groups_by_id[group_id]\n            if group[\"name\"] != group_name:\n                new_group_name_by_id[group_id] = group_name\n\n        grg_lines: list[str] = []\n        for group_id, group_name in new_group_name_by_id.items():\n            group: dict[str, Any] = groups_by_id[group_id]\n            grg_line: str = (\n                \"tv_layercolor \\\"setcolor\\\" {} {} {} {} {} \\\"{}\\\"\"\n            ).format(\n                group[\"clip_id\"],\n                group_id,\n                group[\"red\"],\n                group[\"green\"],\n                group[\"blue\"],\n                group_name\n            )\n            grg_lines.append(grg_line)\n            group[\"name\"] = group_name\n\n        if grg_lines:\n            execute_george_through_file(\"\\n\".join(grg_lines))\n\n    def _prepare_render_layer(\n        self,\n        project_name: str,\n        folder_entity: dict[str, Any],\n        task_entity: dict[str, Any],\n        group_id: int,\n        groups: list[dict[str, Any]],\n        mark_for_review: bool,\n        existing_instance: Optional[CreatedInstance] = None,\n    ) -&gt; Union[CreatedInstance, None]:\n        match_group: Union[dict[str, Any], None] = next(\n            (\n                group\n                for group in groups\n                if group[\"group_id\"] == group_id\n            ),\n            None\n        )\n        if not match_group:\n            return None\n\n        task_name = task_entity[\"name\"]\n        variant: str = match_group[\"name\"]\n        creator: CreateRenderlayer = (\n            self.create_context.creators[CreateRenderlayer.identifier]\n        )\n\n        product_name: str = creator.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            variant,\n            host_name=self.create_context.host_name,\n        )\n        if existing_instance is not None:\n            existing_instance[\"folderPath\"] = folder_entity[\"path\"]\n            existing_instance[\"task\"] = task_name\n            existing_instance[\"productName\"] = product_name\n            return existing_instance\n\n        instance_data: dict[str, str] = {\n            \"folderPath\": folder_entity[\"path\"],\n            \"task\": task_name,\n            \"productType\": creator.product_type,\n            \"variant\": variant,\n        }\n        pre_create_data: dict[str, str] = {\n            \"group_id\": group_id,\n            \"mark_for_review\": mark_for_review\n        }\n        return creator.create(product_name, instance_data, pre_create_data)\n\n    def _prepare_render_passes(\n        self,\n        project_name: str,\n        folder_entity: dict[str, Any],\n        task_entity: dict[str, Any],\n        render_layer_instance: CreatedInstance,\n        layers: list[dict[str, Any]],\n        mark_for_review: bool,\n        existing_render_passes: list[CreatedInstance]\n    ):\n        task_name = task_entity[\"name\"]\n        creator: CreateRenderPass = (\n            self.create_context.creators[CreateRenderPass.identifier]\n        )\n        render_pass_by_layer_name = {}\n        for render_pass in existing_render_passes:\n            for layer_name in render_pass[\"layer_names\"]:\n                render_pass_by_layer_name[layer_name] = render_pass\n\n        for layer in layers:\n            layer_name = layer[\"name\"]\n            variant = layer_name\n            render_pass = render_pass_by_layer_name.get(layer_name)\n            if render_pass is not None:\n                if (render_pass[\"layer_names\"]) &gt; 1:\n                    variant = render_pass[\"variant\"]\n\n            product_name = creator.get_product_name(\n                project_name,\n                folder_entity,\n                task_entity,\n                variant,\n                host_name=self.create_context.host_name,\n                instance=render_pass\n            )\n\n            if render_pass is not None:\n                render_pass[\"folderPath\"] = folder_entity[\"path\"]\n                render_pass[\"task\"] = task_name\n                render_pass[\"productName\"] = product_name\n                continue\n\n            instance_data: dict[str, str] = {\n                \"folderPath\": folder_entity[\"path\"],\n                \"task\": task_name,\n                \"productType\": creator.product_type,\n                \"variant\": variant\n            }\n\n            pre_create_data: dict[str, Any] = {\n                \"render_layer_instance_id\": render_layer_instance.id,\n                \"layer_names\": [layer_name],\n                \"mark_for_review\": mark_for_review\n            }\n            creator.create(product_name, instance_data, pre_create_data)\n\n    def _filter_groups(\n        self,\n        layers_by_group_id,\n        groups_order,\n        only_visible_groups\n    ):\n        new_groups_order = []\n        for group_id in groups_order:\n            layers: list[dict[str, Any]] = layers_by_group_id[group_id]\n            if not layers:\n                continue\n\n            if (\n                only_visible_groups\n                and not any(\n                    layer\n                    for layer in layers\n                    if layer[\"visible\"]\n                )\n            ):\n                continue\n            new_groups_order.append(group_id)\n        return new_groups_order\n\n    def create(self, product_name, instance_data, pre_create_data):\n        project_name: str = self.create_context.get_current_project_name()\n        folder_path: str = instance_data[\"folderPath\"]\n        task_name: str = instance_data[\"task\"]\n        folder_entity: dict[str, Any] = ayon_api.get_folder_by_path(\n            project_name, folder_path)\n        task_entity: dict[str, Any] = ayon_api.get_task_by_name(\n            project_name, folder_entity[\"id\"], task_name\n        )\n\n        render_layers_by_group_id: dict[int, CreatedInstance] = {}\n        render_passes_by_render_layer_id: dict[int, list[CreatedInstance]] = (\n            collections.defaultdict(list)\n        )\n        for instance in self.create_context.instances:\n            if instance.creator_identifier == CreateRenderlayer.identifier:\n                group_id = instance[\"creator_attributes\"][\"group_id\"]\n                render_layers_by_group_id[group_id] = instance\n            elif instance.creator_identifier == CreateRenderPass.identifier:\n                render_layer_id = (\n                    instance\n                    [\"creator_attributes\"]\n                    [\"render_layer_instance_id\"]\n                )\n                render_passes_by_render_layer_id[render_layer_id].append(\n                    instance\n                )\n\n        layers_by_group_id: dict[int, list[dict[str, Any]]] = (\n            collections.defaultdict(list)\n        )\n        scene_layers: list[dict[str, Any]] = get_layers_data()\n        scene_groups: list[dict[str, Any]] = get_groups_data()\n        groups_order: list[int] = []\n        for layer in scene_layers:\n            group_id: int = layer[\"group_id\"]\n            # Skip 'default' group\n            if group_id == 0:\n                continue\n\n            layers_by_group_id[group_id].append(layer)\n            if group_id not in groups_order:\n                groups_order.append(group_id)\n\n        groups_order.reverse()\n\n        mark_layers_for_review = pre_create_data.get(\n            \"mark_layers_for_review\", False\n        )\n        mark_passes_for_review = pre_create_data.get(\n            \"mark_passes_for_review\", False\n        )\n        rename_groups = pre_create_data.get(\"rename_groups\", False)\n        only_visible_groups = pre_create_data.get(\"only_visible_groups\", False)\n        groups_order = self._filter_groups(\n            layers_by_group_id,\n            groups_order,\n            only_visible_groups\n        )\n        if not groups_order:\n            return\n\n        if rename_groups:\n            self._rename_groups(groups_order, scene_groups)\n\n        # Make sure  all render layers are created\n        for group_id in groups_order:\n            instance: Union[CreatedInstance, None] = (\n                self._prepare_render_layer(\n                    project_name,\n                    folder_entity,\n                    task_entity,\n                    group_id,\n                    scene_groups,\n                    mark_layers_for_review,\n                    render_layers_by_group_id.get(group_id),\n                )\n            )\n            if instance is not None:\n                render_layers_by_group_id[group_id] = instance\n\n        for group_id in groups_order:\n            layers: list[dict[str, Any]] = layers_by_group_id[group_id]\n            render_layer_instance: Union[CreatedInstance, None] = (\n                render_layers_by_group_id.get(group_id)\n            )\n            if not layers or render_layer_instance is None:\n                continue\n\n            self._prepare_render_passes(\n                project_name,\n                folder_entity,\n                task_entity,\n                render_layer_instance,\n                layers,\n                mark_passes_for_review,\n                render_passes_by_render_layer_id[render_layer_instance.id]\n            )\n\n    def get_pre_create_attr_defs(self) -&gt; list[AbstractAttrDef]:\n        render_layer_creator: CreateRenderlayer = (\n            self.create_context.creators[CreateRenderlayer.identifier]\n        )\n        render_pass_creator: CreateRenderPass = (\n            self.create_context.creators[CreateRenderPass.identifier]\n        )\n        output = []\n        if self.allow_group_rename:\n            output.extend([\n                BoolDef(\n                    \"rename_groups\",\n                    label=\"Rename color groups\",\n                    tooltip=\"Will rename color groups using studio template\",\n                    default=True\n                ),\n                BoolDef(\n                    \"only_visible_groups\",\n                    label=\"Only visible color groups\",\n                    tooltip=(\n                        \"Render Layers and rename will happen only on color\"\n                        \" groups with visible layers.\"\n                    ),\n                    default=True\n                ),\n                UISeparatorDef()\n            ])\n        output.extend([\n            BoolDef(\n                \"mark_layers_for_review\",\n                label=\"Mark RenderLayers for review\",\n                default=render_layer_creator.mark_for_review\n            ),\n            BoolDef(\n                \"mark_passes_for_review\",\n                label=\"Mark RenderPasses for review\",\n                default=render_pass_creator.mark_for_review\n            )\n        ])\n        return output\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/create/create_review.html","title":"create_review","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/create/create_workfile.html","title":"create_workfile","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_image.html","title":"load_image","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_image.html#client.ayon_tvpaint.plugins.load.load_image.ImportImage","title":"<code>ImportImage</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load image or image sequence to TVPaint as new layer.</p> Source code in <code>client/ayon_tvpaint/plugins/load/load_image.py</code> <pre><code>class ImportImage(plugin.Loader):\n    \"\"\"Load image or image sequence to TVPaint as new layer.\"\"\"\n\n    product_types = {\"render\", \"image\", \"background\", \"plate\", \"review\"}\n    representations = {\"*\"}\n    settings_category = \"tvpaint\"\n\n    label = \"Import Image\"\n    order = 1\n    icon = \"image\"\n    color = \"white\"\n\n    import_script = (\n        \"filepath = \\\"{}\\\"\\n\"\n        \"layer_name = \\\"{}\\\"\\n\"\n        \"tv_loadsequence filepath {}PARSE layer_id\\n\"\n        \"tv_layerrename layer_id layer_name\"\n    )\n\n    defaults = {\n        \"stretch\": True,\n        \"timestretch\": True,\n        \"preload\": True\n    }\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            BoolDef(\n                \"stretch\",\n                label=\"Stretch to project size\",\n                default=cls.defaults[\"stretch\"],\n                tooltip=\"Stretch loaded image/s to project resolution?\"\n            ),\n            BoolDef(\n                \"timestretch\",\n                label=\"Stretch to timeline length\",\n                default=cls.defaults[\"timestretch\"],\n                tooltip=\"Clip loaded image/s to timeline length?\"\n            ),\n            BoolDef(\n                \"preload\",\n                label=\"Preload loaded image/s\",\n                default=cls.defaults[\"preload\"],\n                tooltip=\"Preload image/s?\"\n            )\n        ]\n\n    def load(self, context, name, namespace, options):\n        stretch = options.get(\"stretch\", self.defaults[\"stretch\"])\n        timestretch = options.get(\"timestretch\", self.defaults[\"timestretch\"])\n        preload = options.get(\"preload\", self.defaults[\"preload\"])\n\n        load_options = []\n        if stretch:\n            load_options.append(\"\\\"STRETCH\\\"\")\n        if timestretch:\n            load_options.append(\"\\\"TIMESTRETCH\\\"\")\n        if preload:\n            load_options.append(\"\\\"PRELOAD\\\"\")\n\n        load_options_str = \"\"\n        for load_option in load_options:\n            load_options_str += (load_option + \" \")\n\n        # Prepare layer name\n        folder_name = context[\"folder\"][\"name\"]\n        version_name = context[\"version\"][\"name\"]\n        layer_name = \"{}_{}_v{:0&gt;3}\".format(\n            folder_name,\n            name,\n            version_name\n        )\n        # Fill import script with filename and layer name\n        # - filename mus not contain backwards slashes\n        path = self.filepath_from_context(context).replace(\"\\\\\", \"/\")\n        george_script = self.import_script.format(\n            path,\n            layer_name,\n            load_options_str\n        )\n        return execute_george_through_file(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_reference_image.html","title":"load_reference_image","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_reference_image.html#client.ayon_tvpaint.plugins.load.load_reference_image.LoadImage","title":"<code>LoadImage</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load image or image sequence to TVPaint as new layer.</p> Source code in <code>client/ayon_tvpaint/plugins/load/load_reference_image.py</code> <pre><code>class LoadImage(plugin.Loader):\n    \"\"\"Load image or image sequence to TVPaint as new layer.\"\"\"\n\n    product_types = {\"render\", \"image\", \"background\", \"plate\", \"review\"}\n    representations = {\"*\"}\n    settings_category = \"tvpaint\"\n\n    label = \"Load Image\"\n    order = 1\n    icon = \"image\"\n    color = \"white\"\n\n    import_script = (\n        \"filepath = '\\\"'\\\"{}\\\"'\\\"'\\n\"\n        \"layer_name = \\\"{}\\\"\\n\"\n        \"tv_loadsequence filepath {}PARSE layer_id\\n\"\n        \"tv_layerrename layer_id layer_name\"\n    )\n\n    defaults = {\n        \"stretch\": True,\n        \"timestretch\": True,\n        \"preload\": True\n    }\n\n    @classmethod\n    def get_options(cls, contexts):\n        return [\n            BoolDef(\n                \"stretch\",\n                label=\"Stretch to project size\",\n                default=cls.defaults[\"stretch\"],\n                tooltip=\"Stretch loaded image/s to project resolution?\"\n            ),\n            BoolDef(\n                \"timestretch\",\n                label=\"Stretch to timeline length\",\n                default=cls.defaults[\"timestretch\"],\n                tooltip=\"Clip loaded image/s to timeline length?\"\n            ),\n            BoolDef(\n                \"preload\",\n                label=\"Preload loaded image/s\",\n                default=cls.defaults[\"preload\"],\n                tooltip=\"Preload image/s?\"\n            )\n        ]\n\n    def load(self, context, name, namespace, options):\n        stretch = options.get(\"stretch\", self.defaults[\"stretch\"])\n        timestretch = options.get(\"timestretch\", self.defaults[\"timestretch\"])\n        preload = options.get(\"preload\", self.defaults[\"preload\"])\n\n        load_options = []\n        if stretch:\n            load_options.append(\"\\\"STRETCH\\\"\")\n        if timestretch:\n            load_options.append(\"\\\"TIMESTRETCH\\\"\")\n        if preload:\n            load_options.append(\"\\\"PRELOAD\\\"\")\n\n        load_options_str = \"\"\n        for load_option in load_options:\n            load_options_str += (load_option + \" \")\n\n        # Prepare layer name\n        folder_name = context[\"folder\"][\"name\"]\n        product_name = context[\"product\"][\"name\"]\n        layer_name = self.get_unique_layer_name(folder_name, product_name)\n\n        path = self.filepath_from_context(context)\n\n        # Fill import script with filename and layer name\n        # - filename mus not contain backwards slashes\n        george_script = self.import_script.format(\n            path.replace(\"\\\\\", \"/\"),\n            layer_name,\n            load_options_str\n        )\n\n        execute_george_through_file(george_script)\n\n        loaded_layer = None\n        layers = get_layers_data()\n        for layer in layers:\n            if layer[\"name\"] == layer_name:\n                loaded_layer = layer\n                break\n\n        if loaded_layer is None:\n            raise AssertionError(\n                \"Loading probably failed during execution of george script.\"\n            )\n\n        layer_names = [loaded_layer[\"name\"]]\n        namespace = namespace or layer_name\n        return containerise(\n            name=name,\n            namespace=namespace,\n            members=layer_names,\n            context=context,\n            loader=self.__class__.__name__\n        )\n\n    def _remove_layers(self, layer_names=None, layer_ids=None, layers=None):\n        if not layer_names and not layer_ids:\n            self.log.warning(\"Got empty layer names list.\")\n            return\n\n        if layers is None:\n            layers = get_layers_data()\n\n        available_ids = set(layer[\"layer_id\"] for layer in layers)\n\n        if layer_ids is None:\n            # Backwards compatibility (layer ids were stored instead of names)\n            layer_names_are_ids = True\n            for layer_name in layer_names:\n                if (\n                    not isinstance(layer_name, int)\n                    and not layer_name.isnumeric()\n                ):\n                    layer_names_are_ids = False\n                    break\n\n            if layer_names_are_ids:\n                layer_ids = layer_names\n\n        layer_ids_to_remove = []\n        if layer_ids is not None:\n            for layer_id in layer_ids:\n                if layer_id in available_ids:\n                    layer_ids_to_remove.append(layer_id)\n\n        else:\n            layers_by_name = collections.defaultdict(list)\n            for layer in layers:\n                layers_by_name[layer[\"name\"]].append(layer)\n\n            for layer_name in layer_names:\n                layers = layers_by_name[layer_name]\n                if len(layers) == 1:\n                    layer_ids_to_remove.append(layers[0][\"layer_id\"])\n\n        if not layer_ids_to_remove:\n            self.log.warning(\"No layers to delete.\")\n            return\n\n        george_script_lines = []\n        for layer_id in layer_ids_to_remove:\n            line = \"tv_layerkill {}\".format(layer_id)\n            george_script_lines.append(line)\n        george_script = \"\\n\".join(george_script_lines)\n        execute_george_through_file(george_script)\n\n    def _remove_container(self, container):\n        if not container:\n            return\n        representation = container[\"representation\"]\n        members = self.get_members_from_container(container)\n        host = registered_host()\n        current_containers = host.get_containers()\n        pop_idx = None\n        for idx, cur_con in enumerate(current_containers):\n            cur_members = self.get_members_from_container(cur_con)\n            if (\n                cur_members == members\n                and cur_con[\"representation\"] == representation\n            ):\n                pop_idx = idx\n                break\n\n        if pop_idx is None:\n            self.log.warning(\n                \"Didn't find container in workfile containers. {}\".format(\n                    container\n                )\n            )\n            return\n\n        current_containers.pop(pop_idx)\n        write_workfile_metadata(\n            SECTION_NAME_CONTAINERS, current_containers\n        )\n\n    def remove(self, container):\n        members = self.get_members_from_container(container)\n        self.log.warning(\"Layers to delete {}\".format(members))\n        self._remove_layers(members)\n        self._remove_container(container)\n\n    def switch(self, container, representation):\n        self.update(container, representation)\n\n    def update(self, container, context):\n        \"\"\"Replace container with different version.\n\n        New layers are loaded as first step. Then is tried to change data in\n        new layers with data from old layers. When that is done old layers are\n        removed.\n        \"\"\"\n\n        # Create new containers first\n        # Get layer ids from previous container\n        old_layer_names = self.get_members_from_container(container)\n\n        # Backwards compatibility (layer ids were stored instead of names)\n        old_layers_are_ids = True\n        for name in old_layer_names:\n            if isinstance(name, int) or name.isnumeric():\n                continue\n            old_layers_are_ids = False\n            break\n\n        old_layers = []\n        layers = get_layers_data()\n        previous_layer_ids = set(layer[\"layer_id\"] for layer in layers)\n        if old_layers_are_ids:\n            for layer in layers:\n                if layer[\"layer_id\"] in old_layer_names:\n                    old_layers.append(layer)\n        else:\n            layers_by_name = collections.defaultdict(list)\n            for layer in layers:\n                layers_by_name[layer[\"name\"]].append(layer)\n\n            for layer_name in old_layer_names:\n                layers = layers_by_name[layer_name]\n                if len(layers) == 1:\n                    old_layers.append(layers[0])\n\n        # Prepare few data\n        new_start_position = None\n        new_group_id = None\n        layer_ids_to_remove = set()\n        for layer in old_layers:\n            layer_ids_to_remove.add(layer[\"layer_id\"])\n            position = layer[\"position\"]\n            group_id = layer[\"group_id\"]\n            if new_start_position is None:\n                new_start_position = position\n            elif new_start_position &gt; position:\n                new_start_position = position\n\n            if new_group_id is None:\n                new_group_id = group_id\n            elif new_group_id &lt; 0:\n                continue\n            elif new_group_id != group_id:\n                new_group_id = -1\n\n        # Remove old container\n        self._remove_container(container)\n        # Remove old layers\n        self._remove_layers(layer_ids=layer_ids_to_remove)\n\n        name = container[\"name\"]\n        namespace = container[\"namespace\"]\n        new_container = self.load(context, name, namespace, {})\n        new_layer_names = self.get_members_from_container(new_container)\n\n        layers = get_layers_data()\n\n        new_layers = []\n        for layer in layers:\n            if layer[\"layer_id\"] in previous_layer_ids:\n                continue\n            if layer[\"name\"] in new_layer_names:\n                new_layers.append(layer)\n\n        george_script_lines = []\n        # Group new layers to same group as previous container layers had\n        # - all old layers must be under same group\n        if new_group_id is not None and new_group_id &gt; 0:\n            for layer in new_layers:\n                line = \"tv_layercolor \\\"set\\\" {} {}\".format(\n                    layer[\"layer_id\"], new_group_id\n                )\n                george_script_lines.append(line)\n\n        # Rename new layer to have same name\n        # - only if both old and new have one layer\n        if len(old_layers) == 1 and len(new_layers) == 1:\n            layer_name = old_layers[0][\"name\"]\n            george_script_lines.append(\n                \"tv_layerrename {} \\\"{}\\\"\".format(\n                    new_layers[0][\"layer_id\"], layer_name\n                )\n            )\n\n        # Change position of new layer\n        # - this must be done before remove old layers\n        if len(new_layers) == 1 and new_start_position is not None:\n            new_layer = new_layers[0]\n            george_script_lines.extend([\n                \"tv_layerset {}\".format(new_layer[\"layer_id\"]),\n                \"tv_layermove {}\".format(new_start_position)\n            ])\n\n        # Execute george scripts if there are any\n        if george_script_lines:\n            george_script = \"\\n\".join(george_script_lines)\n            execute_george_through_file(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_reference_image.html#client.ayon_tvpaint.plugins.load.load_reference_image.LoadImage.update","title":"<code>update(container, context)</code>","text":"<p>Replace container with different version.</p> <p>New layers are loaded as first step. Then is tried to change data in new layers with data from old layers. When that is done old layers are removed.</p> Source code in <code>client/ayon_tvpaint/plugins/load/load_reference_image.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Replace container with different version.\n\n    New layers are loaded as first step. Then is tried to change data in\n    new layers with data from old layers. When that is done old layers are\n    removed.\n    \"\"\"\n\n    # Create new containers first\n    # Get layer ids from previous container\n    old_layer_names = self.get_members_from_container(container)\n\n    # Backwards compatibility (layer ids were stored instead of names)\n    old_layers_are_ids = True\n    for name in old_layer_names:\n        if isinstance(name, int) or name.isnumeric():\n            continue\n        old_layers_are_ids = False\n        break\n\n    old_layers = []\n    layers = get_layers_data()\n    previous_layer_ids = set(layer[\"layer_id\"] for layer in layers)\n    if old_layers_are_ids:\n        for layer in layers:\n            if layer[\"layer_id\"] in old_layer_names:\n                old_layers.append(layer)\n    else:\n        layers_by_name = collections.defaultdict(list)\n        for layer in layers:\n            layers_by_name[layer[\"name\"]].append(layer)\n\n        for layer_name in old_layer_names:\n            layers = layers_by_name[layer_name]\n            if len(layers) == 1:\n                old_layers.append(layers[0])\n\n    # Prepare few data\n    new_start_position = None\n    new_group_id = None\n    layer_ids_to_remove = set()\n    for layer in old_layers:\n        layer_ids_to_remove.add(layer[\"layer_id\"])\n        position = layer[\"position\"]\n        group_id = layer[\"group_id\"]\n        if new_start_position is None:\n            new_start_position = position\n        elif new_start_position &gt; position:\n            new_start_position = position\n\n        if new_group_id is None:\n            new_group_id = group_id\n        elif new_group_id &lt; 0:\n            continue\n        elif new_group_id != group_id:\n            new_group_id = -1\n\n    # Remove old container\n    self._remove_container(container)\n    # Remove old layers\n    self._remove_layers(layer_ids=layer_ids_to_remove)\n\n    name = container[\"name\"]\n    namespace = container[\"namespace\"]\n    new_container = self.load(context, name, namespace, {})\n    new_layer_names = self.get_members_from_container(new_container)\n\n    layers = get_layers_data()\n\n    new_layers = []\n    for layer in layers:\n        if layer[\"layer_id\"] in previous_layer_ids:\n            continue\n        if layer[\"name\"] in new_layer_names:\n            new_layers.append(layer)\n\n    george_script_lines = []\n    # Group new layers to same group as previous container layers had\n    # - all old layers must be under same group\n    if new_group_id is not None and new_group_id &gt; 0:\n        for layer in new_layers:\n            line = \"tv_layercolor \\\"set\\\" {} {}\".format(\n                layer[\"layer_id\"], new_group_id\n            )\n            george_script_lines.append(line)\n\n    # Rename new layer to have same name\n    # - only if both old and new have one layer\n    if len(old_layers) == 1 and len(new_layers) == 1:\n        layer_name = old_layers[0][\"name\"]\n        george_script_lines.append(\n            \"tv_layerrename {} \\\"{}\\\"\".format(\n                new_layers[0][\"layer_id\"], layer_name\n            )\n        )\n\n    # Change position of new layer\n    # - this must be done before remove old layers\n    if len(new_layers) == 1 and new_start_position is not None:\n        new_layer = new_layers[0]\n        george_script_lines.extend([\n            \"tv_layerset {}\".format(new_layer[\"layer_id\"]),\n            \"tv_layermove {}\".format(new_start_position)\n        ])\n\n    # Execute george scripts if there are any\n    if george_script_lines:\n        george_script = \"\\n\".join(george_script_lines)\n        execute_george_through_file(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_sound.html","title":"load_sound","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_sound.html#client.ayon_tvpaint.plugins.load.load_sound.ImportSound","title":"<code>ImportSound</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load sound to TVPaint.</p> <p>Sound layers does not have ids but only position index so we can't reference them as we can't say which is which input.</p> <p>We might do that (in future) by input path. Which may be identifier if we'll allow only one loaded instance of the representation as an audio.</p> <p>This plugin does not work for all version of TVPaint. Known working version is TVPaint 11.0.10 .</p> <p>It is allowed to load video files as sound but it does not check if video file contain any audio.</p> Source code in <code>client/ayon_tvpaint/plugins/load/load_sound.py</code> <pre><code>class ImportSound(plugin.Loader):\n    \"\"\"Load sound to TVPaint.\n\n    Sound layers does not have ids but only position index so we can't\n    reference them as we can't say which is which input.\n\n    We might do that (in future) by input path. Which may be identifier if\n    we'll allow only one loaded instance of the representation as an audio.\n\n    This plugin does not work for all version of TVPaint. Known working\n    version is TVPaint 11.0.10 .\n\n    It is allowed to load video files as sound but it does not check if video\n    file contain any audio.\n    \"\"\"\n\n    product_types = {\"audio\", \"review\", \"plate\"}\n    representations = {\"*\"}\n\n    label = \"Import Sound\"\n    order = 1\n    icon = \"image\"\n    color = \"white\"\n\n    import_script_lines = (\n        \"sound_path = '\\\"'\\\"{}\\\"'\\\"'\",\n        \"output_path = \\\"{}\\\"\",\n        # Try to get sound clip info to check if we are in TVPaint that can\n        # load sound\n        \"tv_clipcurrentid\",\n        \"clip_id = result\",\n        \"tv_soundclipinfo clip_id 0\",\n        \"IF CMP(result,\\\"\\\")==1\",\n        (\n            \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"'\"\n            \" 'success|'\"\n        ),\n        \"EXIT\",\n        \"END\",\n\n        \"tv_soundclipnew sound_path\",\n        \"line = 'success|'result\",\n        \"tv_writetextfile \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' line\"\n    )\n\n    def load(self, context, name, namespace, options):\n        # Create temp file for output\n        output_file = tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"ayon_tvp_\", suffix=\".txt\", delete=False\n        )\n        output_file.close()\n        output_filepath = output_file.name.replace(\"\\\\\", \"/\")\n\n        # Prepare george script\n        path = self.filepath_from_context(context).replace(\"\\\\\", \"/\")\n        import_script = \"\\n\".join(self.import_script_lines)\n        george_script = import_script.format(\n            path,\n            output_filepath\n        )\n        self.log.info(\"*** George script:\\n{}\\n***\".format(george_script))\n        # Execute geoge script\n        execute_george_through_file(george_script)\n\n        # Read output file\n        lines = []\n        with open(output_filepath, \"r\") as file_stream:\n            for line in file_stream:\n                line = line.rstrip()\n                if line:\n                    lines.append(line)\n\n        # Clean up temp file\n        os.remove(output_filepath)\n\n        output = {}\n        for line in lines:\n            key, value = line.split(\"|\")\n            output[key] = value\n\n        success = output.get(\"success\")\n        # Successfully loaded sound\n        if success == \"0\":\n            return\n\n        if success == \"\":\n            raise ValueError(\n                \"Your TVPaint version does not support loading of\"\n                \" sound through George script. Please use manual load.\"\n            )\n\n        if success is None:\n            raise ValueError(\n                \"Unknown error happened during load.\"\n                \" Please report and try to use manual load.\"\n            )\n\n        # Possible errors by TVPaint documentation\n        # https://www.tvpaint.com/doc/tvpaint-animation-11/george-commands#tv_soundclipnew\n        if success == \"-1\":\n            raise ValueError(\n                \"BUG: George command did not get enough arguments.\"\n            )\n\n        if success == \"-2\":\n            # Who know what does that mean?\n            raise ValueError(\"No current clip without mixer.\")\n\n        if success == \"-3\":\n            raise ValueError(\"TVPaint couldn't read the file.\")\n\n        if success == \"-4\":\n            raise ValueError(\"TVPaint couldn't add the track.\")\n\n        raise ValueError(\"BUG: Unknown success value {}.\".format(success))\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_workfile.html","title":"load_workfile","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/load/load_workfile.html#client.ayon_tvpaint.plugins.load.load_workfile.LoadWorkfile","title":"<code>LoadWorkfile</code>","text":"<p>               Bases: <code>Loader</code></p> <p>Load workfile.</p> Source code in <code>client/ayon_tvpaint/plugins/load/load_workfile.py</code> <pre><code>class LoadWorkfile(plugin.Loader):\n    \"\"\"Load workfile.\"\"\"\n\n    product_types = {\"workfile\"}\n    representations = {\"tvpp\"}\n\n    label = \"Load Workfile\"\n\n    def load(self, context, name, namespace, options):\n        # Load context of current workfile as first thing\n        #   - which context and extension has\n        filepath = self.filepath_from_context(context)\n        filepath = filepath.replace(\"\\\\\", \"/\")\n\n        if not os.path.exists(filepath):\n            raise FileExistsError(\n                \"The loaded file does not exist. Try downloading it first.\"\n            )\n\n        host = registered_host()\n        current_file = host.get_current_workfile()\n        work_context = get_current_workfile_context()\n\n        george_script = \"tv_LoadProject '\\\"'\\\"{}\\\"'\\\"'\".format(\n            filepath\n        )\n        execute_george_through_file(george_script)\n\n        # Save workfile.\n        host_name = \"tvpaint\"\n        if \"project_name\" in work_context:\n            project_name = context[\"project\"][\"name\"]\n            folder_path = context[\"folder\"][\"path\"]\n            # Get task from version (is not part of representation context)\n            version_entity = context[\"version\"]\n            task_id = version_entity.get(\"taskId\")\n            task_name = None\n            if task_id:\n                task_entity = ayon_api.get_task_by_id(\n                    project_name, task_id, fields={\"name\"}\n                )\n                if task_entity:\n                    task_name = task_entity[\"name\"]\n        else:\n            project_name = work_context.get(\"project_name\")\n            folder_path = work_context.get(\"folder_path\")\n            task_name = work_context.get(\"task_name\")\n\n        # Far cases when there is workfile without work_context\n        if not folder_path:\n            current_context = get_current_context()\n            project_name = current_context.get(\"project_name\")\n            folder_path = current_context.get(\"folder_path\")\n            task_name = current_context.get(\"task_name\")\n\n        template_key = get_workfile_template_key_from_context(\n            project_name,\n            folder_path,\n            task_name,\n            host_name,\n        )\n        anatomy = Anatomy(project_name)\n\n        data = get_template_data_with_names(\n            project_name, folder_path, task_name, host_name\n        )\n        data[\"root\"] = anatomy.roots\n\n        work_template = anatomy.get_template_item(\"work\", template_key)\n\n        # Define saving file extension\n        extensions = host.get_workfile_extensions()\n        if current_file:\n            # Match the extension of current file\n            _, extension = os.path.splitext(current_file)\n        else:\n            # Fall back to the first extension supported for this host.\n            extension = extensions[0]\n\n        data[\"ext\"] = extension.lstrip(\".\")\n\n        work_root = work_template[\"directory\"].format_strict(data)\n        version = get_last_workfile_with_version(\n            work_root, work_template[\"file\"].template, data, extensions\n        )[1]\n\n        if version is None:\n            version = get_versioning_start(\n                project_name,\n                \"tvpaint\",\n                task_name=task_name,\n                task_type=data[\"task\"][\"type\"],\n                product_type=\"workfile\"\n            )\n        else:\n            version += 1\n\n        data[\"version\"] = version\n\n        filename = work_template[\"file\"].format_strict(data)\n        path = os.path.join(work_root, filename)\n        host.save_workfile(path)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/collect_instance_frames.html","title":"collect_instance_frames","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/collect_instance_frames.html#client.ayon_tvpaint.plugins.publish.collect_instance_frames.CollectOutputFrameRange","title":"<code>CollectOutputFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect frame start/end from context.</p> <p>When instances are collected context does not contain <code>frameStart</code> and <code>frameEnd</code> keys yet. They are collected in global plugin <code>CollectContextEntities</code>.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/collect_instance_frames.py</code> <pre><code>class CollectOutputFrameRange(pyblish.api.InstancePlugin):\n    \"\"\"Collect frame start/end from context.\n\n    When instances are collected context does not contain `frameStart` and\n    `frameEnd` keys yet. They are collected in global plugin\n    `CollectContextEntities`.\n    \"\"\"\n\n    label = \"Collect output frame range\"\n    order = pyblish.api.CollectorOrder + 0.4999\n    hosts = [\"tvpaint\"]\n    families = [\"review\", \"render\"]\n\n    settings_category = \"tvpaint\"\n\n    def process(self, instance):\n        entity = instance.data.get(\"taskEntity\")\n        if not entity:\n            # Task may be optional for an instance\n            entity = instance.data.get(\"folderEntity\")\n        if not entity:\n            return\n\n        context = instance.context\n\n        frame_start = entity[\"attrib\"][\"frameStart\"]\n        fps = entity[\"attrib\"][\"fps\"]\n        frame_end = frame_start + (\n            context.data[\"sceneMarkOut\"] - context.data[\"sceneMarkIn\"]\n        )\n        instance.data[\"fps\"] = fps\n        instance.data[\"frameStart\"] = frame_start\n        instance.data[\"frameEnd\"] = frame_end\n        self.log.info(\n            \"Set frames {}-{} on instance {} \".format(\n                frame_start, frame_end, instance.data[\"productName\"]\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/collect_render_instances.html","title":"collect_render_instances","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/collect_workfile_data.html","title":"collect_workfile_data","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/collect_workfile_data.html#client.ayon_tvpaint.plugins.publish.collect_workfile_data.CollectWorkfileData","title":"<code>CollectWorkfileData</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> Source code in <code>client/ayon_tvpaint/plugins/publish/collect_workfile_data.py</code> <pre><code>class CollectWorkfileData(pyblish.api.ContextPlugin):\n    label = \"Collect Workfile Data\"\n    order = pyblish.api.CollectorOrder - 0.45\n    hosts = [\"tvpaint\"]\n    actions = [ResetTVPaintWorkfileMetadata]\n\n    settings_category = \"tvpaint\"\n\n    def process(self, context):\n        current_project_id = execute_george(\"tv_projectcurrentid\")\n        execute_george(\"tv_projectselect {}\".format(current_project_id))\n\n        # Collect and store current context to have reference\n        current_context = {\n            \"project_name\": context.data[\"projectName\"],\n            \"folder_path\": context.data[\"folderPath\"],\n            \"task_name\": context.data[\"task\"]\n        }\n        self.log.debug(\"Current context is: {}\".format(current_context))\n\n        # Collect context from workfile metadata\n        self.log.info(\"Collecting workfile context\")\n\n        workfile_context = get_current_workfile_context()\n        if \"project\" in workfile_context:\n            workfile_context = {\n                \"project_name\": workfile_context.get(\"project\"),\n                \"folder_path\": workfile_context.get(\"asset\"),\n                \"task_name\": workfile_context.get(\"task\"),\n            }\n        # Store workfile context to pyblish context\n        context.data[\"workfile_context\"] = workfile_context\n        if workfile_context:\n            # Change current context with context from workfile\n            key_map = (\n                (\"AYON_FOLDER_PATH\", \"folder_path\"),\n                (\"AYON_TASK_NAME\", \"task_name\")\n            )\n            for env_key, key in key_map:\n                os.environ[env_key] = workfile_context[key]\n            self.log.info(\"Context changed to: {}\".format(workfile_context))\n\n            folder_path = workfile_context[\"folder_path\"]\n            task_name = workfile_context[\"task_name\"]\n\n        else:\n            folder_path = current_context[\"folder_path\"]\n            task_name = current_context[\"task_name\"]\n            # Handle older workfiles or workfiles without metadata\n            self.log.warning((\n                \"Workfile does not contain information about context.\"\n                \" Using current Session context.\"\n            ))\n\n        # Store context folder path\n        context.data[\"folderPath\"] = folder_path\n        context.data[\"task\"] = task_name\n        self.log.info(\n            \"Context is set to Folder: \\\"{}\\\" and Task: \\\"{}\\\"\".format(\n                folder_path, task_name\n            )\n        )\n\n        # Collect instances\n        self.log.info(\"Collecting instance data from workfile\")\n        instance_data = list_instances()\n        context.data[\"workfileInstances\"] = instance_data\n        self.log.debug(\n            \"Instance data:\\\"{}\".format(json.dumps(instance_data, indent=4))\n        )\n\n        # Collect information about layers\n        self.log.info(\"Collecting layers data from workfile\")\n        layers_data = get_layers_data()\n        layers_by_name = {}\n        for layer in layers_data:\n            layer_name = layer[\"name\"]\n            if layer_name not in layers_by_name:\n                layers_by_name[layer_name] = []\n            layers_by_name[layer_name].append(layer)\n        context.data[\"layersData\"] = layers_data\n        context.data[\"layersByName\"] = layers_by_name\n\n        self.log.debug(\n            \"Layers data:\\\"{}\".format(json.dumps(layers_data, indent=4))\n        )\n\n        # Collect information about groups\n        self.log.info(\"Collecting groups data from workfile\")\n        group_data = get_groups_data()\n        context.data[\"groupsData\"] = group_data\n        self.log.debug(\n            \"Group data:\\\"{}\".format(json.dumps(group_data, indent=4))\n        )\n\n        self.log.info(\"Collecting scene data from workfile\")\n        workfile_info_parts = execute_george(\"tv_projectinfo\").split(\" \")\n\n        # Project frame start - not used\n        workfile_info_parts.pop(-1)\n        field_order = workfile_info_parts.pop(-1)\n        frame_rate = float(workfile_info_parts.pop(-1))\n        pixel_apsect = float(workfile_info_parts.pop(-1))\n        height = int(workfile_info_parts.pop(-1))\n        width = int(workfile_info_parts.pop(-1))\n        workfile_path = \" \".join(workfile_info_parts).replace(\"\\\"\", \"\")\n\n        # Marks return as \"{frame - 1} {state} \", example \"0 set\".\n        result = execute_george(\"tv_markin\")\n        mark_in_frame, mark_in_state, _ = result.split(\" \")\n\n        result = execute_george(\"tv_markout\")\n        mark_out_frame, mark_out_state, _ = result.split(\" \")\n\n        current_scene_id = execute_george(\"tv_scenecurrentid\")\n        scene_index = 0\n        while True:\n            scene_id = execute_george(f\"tv_sceneenumid {scene_index}\")\n            if scene_id == \"none\":\n                raise PublishError(\n                    \"Current scene was not found in workfile.\"\n                )\n\n            if scene_id == current_scene_id:\n                break\n            scene_index += 1\n\n        current_clip_id = execute_george(\"tv_clipcurrentid\")\n        clip_index = 0\n        while True:\n            clip_id = execute_george(\n                f\"tv_clipenumid {current_scene_id} {clip_index}\"\n            )\n            if clip_id == \"none\":\n                raise PublishError(\n                    \"Current clip was not found in scene.\"\n                )\n\n            if clip_id == current_clip_id:\n                break\n            clip_index += 1\n\n        scene_data = {\n            \"currentFile\": workfile_path,\n            \"sceneWidth\": width,\n            \"sceneHeight\": height,\n            \"scenePixelAspect\": pixel_apsect,\n            \"sceneFps\": frame_rate,\n            \"sceneFieldOrder\": field_order,\n            \"sceneMarkIn\": int(mark_in_frame),\n            \"sceneMarkInState\": mark_in_state == \"set\",\n            \"sceneMarkOut\": int(mark_out_frame),\n            \"sceneMarkOutState\": mark_out_state == \"set\",\n            \"sceneStartFrame\": int(execute_george(\"tv_startframe\")),\n            \"sceneBgColor\": self._get_bg_color(),\n            \"sceneSceneIdx\": scene_index,\n            \"sceneClipIdx\": clip_index,\n        }\n        self.log.debug(\n            \"Scene data: {}\".format(json.dumps(scene_data, indent=4))\n        )\n        context.data.update(scene_data)\n\n    def _get_bg_color(self):\n        \"\"\"Background color set on scene.\n\n        Is important for review exporting where scene bg color is used as\n        background.\n        \"\"\"\n        output_file = tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"a_tvp_\", suffix=\".txt\", delete=False\n        )\n        output_file.close()\n        output_filepath = output_file.name.replace(\"\\\\\", \"/\")\n        george_script_lines = [\n            # Variable containing full path to output file\n            \"output_path = \\\"{}\\\"\".format(output_filepath),\n            \"tv_background\",\n            \"bg_color = result\",\n            # Write data to output file\n            (\n                \"tv_writetextfile\"\n                \" \\\"strict\\\" \\\"append\\\" '\\\"'output_path'\\\"' bg_color\"\n            )\n        ]\n\n        george_script = \"\\n\".join(george_script_lines)\n        execute_george_through_file(george_script)\n\n        with open(output_filepath, \"r\") as stream:\n            data = stream.read()\n\n        os.remove(output_filepath)\n        data = data.strip()\n        if not data:\n            return None\n        return data.split(\" \")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/collect_workfile_data.html#client.ayon_tvpaint.plugins.publish.collect_workfile_data.ResetTVPaintWorkfileMetadata","title":"<code>ResetTVPaintWorkfileMetadata</code>","text":"<p>               Bases: <code>Action</code></p> <p>Fix invalid metadata in workfile.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/collect_workfile_data.py</code> <pre><code>class ResetTVPaintWorkfileMetadata(pyblish.api.Action):\n    \"\"\"Fix invalid metadata in workfile.\"\"\"\n    label = \"Reset invalid workfile metadata\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n        metadata_keys = {\n            SECTION_NAME_CONTEXT: {},\n            SECTION_NAME_INSTANCES: [],\n            SECTION_NAME_CONTAINERS: []\n        }\n        for metadata_key, default in metadata_keys.items():\n            json_string = get_workfile_metadata_string(metadata_key)\n            if not json_string:\n                continue\n\n            try:\n                return json.loads(json_string)\n            except Exception:\n                self.log.warning(\n                    (\n                        \"Couldn't parse metadata from key \\\"{}\\\".\"\n                        \" Will reset to default value \\\"{}\\\".\"\n                        \" Loaded value was: {}\"\n                    ).format(metadata_key, default, json_string),\n                    exc_info=True\n                )\n                write_workfile_metadata(metadata_key, default)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/extract_convert_to_exr.html","title":"extract_convert_to_exr","text":"<p>Plugin converting png files from ExtractSequence into exrs.</p> Requires <p>ExtractSequence - source of PNG ExtractReview - review was already created so we can convert to any exr</p>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/extract_sequence.html","title":"extract_sequence","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/extract_sequence.html#client.ayon_tvpaint.plugins.publish.extract_sequence.ExtractSequence","title":"<code>ExtractSequence</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> Source code in <code>client/ayon_tvpaint/plugins/publish/extract_sequence.py</code> <pre><code>class ExtractSequence(pyblish.api.InstancePlugin):\n    label = \"Extract Sequence\"\n    order = pyblish.api.ExtractorOrder\n    hosts = [\"tvpaint\"]\n    families = [\"review\", \"render\"]\n\n    settings_category = \"tvpaint\"\n\n    # Modifiable with settings\n    review_bg = [255, 255, 255, 1.0]\n\n    def process(self, instance):\n        if instance.data.get(\"farm\"):\n            return\n\n        self.log.info(\n            \"* Processing instance \\\"{}\\\"\".format(instance.data[\"label\"])\n        )\n\n        # Get all layers and filter out not visible\n        layers = instance.data[\"layers\"]\n        filtered_layers = [\n            layer\n            for layer in layers\n            if layer[\"visible\"]\n        ]\n        layer_names = [str(layer[\"name\"]) for layer in filtered_layers]\n        if not layer_names:\n            self.log.info(\n                \"None of the layers from the instance\"\n                \" are visible. Extraction skipped.\"\n            )\n            return\n\n        joined_layer_names = \", \".join(\n            [\"\\\"{}\\\"\".format(name) for name in layer_names]\n        )\n        self.log.debug(\n            \"Instance has {} layers with names: {}\".format(\n                len(layer_names), joined_layer_names\n            )\n        )\n\n        ignore_layers_transparency = instance.data.get(\n            \"ignoreLayersTransparency\", False\n        )\n\n        mark_in = instance.context.data[\"sceneMarkIn\"]\n        mark_out = instance.context.data[\"sceneMarkOut\"]\n\n        # Change scene Start Frame to 0 to prevent frame index issues\n        #   - issue is that TVPaint versions deal with frame indexes in a\n        #     different way when Start Frame is not `0`\n        # NOTE It will be set back after rendering\n        scene_start_frame = instance.context.data[\"sceneStartFrame\"]\n        execute_george(\"tv_startframe 0\")\n\n        # Frame start/end may be stored as float\n        frame_start = int(instance.data[\"frameStart\"])\n\n        # Handles are not stored per instance but on Context\n        handle_start = instance.context.data[\"handleStart\"]\n\n        scene_bg_color = instance.context.data[\"sceneBgColor\"]\n\n        # Prepare output frames\n        output_frame_start = frame_start - handle_start\n\n        # Change output frame start to 0 if handles cause it's negative number\n        if output_frame_start &lt; 0:\n            self.log.warning((\n                \"Frame start with handles has negative value.\"\n                \" Changed to \\\"0\\\". Frames start: {}, Handle Start: {}\"\n            ).format(frame_start, handle_start))\n            output_frame_start = 0\n\n        # Calculate frame end\n        output_frame_end = output_frame_start + (mark_out - mark_in)\n\n        # Save to staging dir\n        output_dir = instance.data.get(\"stagingDir\")\n        if not output_dir:\n            # Create temp folder if staging dir is not set\n            output_dir = (\n                tempfile.mkdtemp(prefix=\"tvpaint_render_\")\n            ).replace(\"\\\\\", \"/\")\n            instance.data[\"stagingDir\"] = output_dir\n\n        self.log.debug(\n            \"Files will be rendered to folder: {}\".format(output_dir)\n        )\n\n        if instance.data[\"productType\"] == \"review\":\n            result = self.render_review(\n                output_dir, mark_in, mark_out, scene_bg_color\n            )\n        else:\n            # Render output\n            result = self.render(\n                output_dir,\n                mark_in,\n                mark_out,\n                filtered_layers,\n                ignore_layers_transparency\n            )\n\n        output_filepaths_by_frame_idx, thumbnail_fullpath = result\n\n        # Change scene frame Start back to previous value\n        execute_george(\"tv_startframe {}\".format(scene_start_frame))\n\n        # Sequence of one frame\n        if not output_filepaths_by_frame_idx:\n            self.log.warning(\"Extractor did not create any output.\")\n            return\n\n        repre_files = self._rename_output_files(\n            output_filepaths_by_frame_idx,\n            mark_in,\n            mark_out,\n            output_frame_start\n        )\n\n        # Fill tags and new families from project settings\n        instance_families = get_publish_instance_families(instance)\n        tags = []\n        if \"review\" in instance_families:\n            tags.append(\"review\")\n\n        # Sequence of one frame\n        single_file = len(repre_files) == 1\n        if single_file:\n            repre_files = repre_files[0]\n\n        # Extension is hardcoded\n        #   - changing extension would require change code\n        new_repre = {\n            \"name\": \"png\",\n            \"ext\": \"png\",\n            \"files\": repre_files,\n            \"stagingDir\": output_dir,\n            \"tags\": tags\n        }\n\n        if not single_file:\n            new_repre[\"frameStart\"] = output_frame_start\n            new_repre[\"frameEnd\"] = output_frame_end\n\n        self.log.debug(\"Creating new representation: {}\".format(new_repre))\n\n        instance.data[\"representations\"].append(new_repre)\n\n        if not thumbnail_fullpath:\n            return\n\n        thumbnail_ext = os.path.splitext(\n            thumbnail_fullpath\n        )[1].replace(\".\", \"\")\n        # Create thumbnail representation\n        thumbnail_repre = {\n            \"name\": \"thumbnail\",\n            \"ext\": thumbnail_ext,\n            \"outputName\": \"thumb\",\n            \"files\": os.path.basename(thumbnail_fullpath),\n            \"stagingDir\": output_dir,\n            \"tags\": [\"thumbnail\"]\n        }\n        instance.data[\"representations\"].append(thumbnail_repre)\n\n    def _rename_output_files(\n        self, filepaths_by_frame, mark_in, mark_out, output_frame_start\n    ):\n        new_filepaths_by_frame = rename_filepaths_by_frame_start(\n            filepaths_by_frame, mark_in, mark_out, output_frame_start\n        )\n\n        repre_filenames = []\n        for filepath in new_filepaths_by_frame.values():\n            repre_filenames.append(os.path.basename(filepath))\n\n        if mark_in &lt; output_frame_start:\n            repre_filenames = list(reversed(repre_filenames))\n\n        return repre_filenames\n\n    def render_review(\n        self, output_dir, mark_in, mark_out, scene_bg_color\n    ):\n        \"\"\" Export images from TVPaint using `tv_savesequence` command.\n\n        Args:\n            output_dir (str): Directory where files will be stored.\n            mark_in (int): Starting frame index from which export will begin.\n            mark_out (int): On which frame index export will end.\n            scene_bg_color (list): Bg color set in scene. Result of george\n                script command `tv_background`.\n\n        Returns:\n            tuple: With 2 items first is list of filenames second is path to\n                thumbnail.\n        \"\"\"\n        filename_template = get_frame_filename_template(mark_out)\n\n        self.log.debug(\"Preparing data for rendering.\")\n        first_frame_filepath = os.path.join(\n            output_dir,\n            filename_template.format(frame=mark_in)\n        )\n\n        bg_color = self._get_review_bg_color()\n\n        george_script_lines = [\n            # Change bg color to color from settings\n            \"tv_background \\\"color\\\" {} {} {}\".format(*bg_color),\n            \"tv_SaveMode \\\"PNG\\\"\",\n            \"export_path = \\\"{}\\\"\".format(\n                first_frame_filepath.replace(\"\\\\\", \"/\")\n            ),\n            \"tv_savesequence '\\\"'export_path'\\\"' {} {}\".format(\n                mark_in, mark_out\n            )\n        ]\n        if scene_bg_color:\n            # Change bg color back to previous scene bg color\n            _scene_bg_color = copy.deepcopy(scene_bg_color)\n            bg_type = _scene_bg_color.pop(0)\n            orig_color_command = [\n                \"tv_background\",\n                \"\\\"{}\\\"\".format(bg_type)\n            ]\n            orig_color_command.extend(_scene_bg_color)\n\n            george_script_lines.append(\" \".join(orig_color_command))\n\n        execute_george_through_file(\"\\n\".join(george_script_lines))\n\n        first_frame_filepath = None\n        output_filepaths_by_frame_idx = {}\n        for frame_idx in range(mark_in, mark_out + 1):\n            filename = filename_template.format(frame=frame_idx)\n            filepath = os.path.join(output_dir, filename)\n\n            output_filepaths_by_frame_idx[frame_idx] = filepath\n\n            if not os.path.exists(filepath):\n                raise KnownPublishError(\n                    \"Output was not rendered. File was not found {}\".format(\n                        filepath\n                    )\n                )\n\n            if first_frame_filepath is None:\n                first_frame_filepath = filepath\n\n        thumbnail_filepath = None\n        if first_frame_filepath and os.path.exists(first_frame_filepath):\n            thumbnail_filepath = os.path.join(output_dir, \"thumbnail.jpg\")\n            source_img = Image.open(first_frame_filepath)\n            if source_img.mode.lower() != \"rgb\":\n                source_img = source_img.convert(\"RGB\")\n            source_img.save(thumbnail_filepath)\n\n        return output_filepaths_by_frame_idx, thumbnail_filepath\n\n    def render(\n        self, output_dir, mark_in, mark_out, layers, ignore_layer_opacity\n    ):\n        \"\"\" Export images from TVPaint.\n\n        Args:\n            output_dir (str): Directory where files will be stored.\n            mark_in (int): Starting frame index from which export will begin.\n            mark_out (int): On which frame index export will end.\n            layers (list): List of layers to be exported.\n            ignore_layer_opacity (bool): Layer's opacity will be ignored.\n\n        Returns:\n            tuple: With 2 items first is list of filenames second is path to\n                thumbnail.\n        \"\"\"\n        self.log.debug(\"Preparing data for rendering.\")\n\n        # Map layers by position\n        layers_by_position = {}\n        layers_by_id = {}\n        layer_ids = []\n        for layer in layers:\n            layer_id = layer[\"layer_id\"]\n            position = layer[\"position\"]\n            layers_by_position[position] = layer\n            layers_by_id[layer_id] = layer\n\n            layer_ids.append(layer_id)\n\n        # Sort layer positions in reverse order\n        sorted_positions = list(reversed(sorted(layers_by_position.keys())))\n        if not sorted_positions:\n            return [], None\n\n        self.log.debug(\"Collecting pre/post behavior of individual layers.\")\n        behavior_by_layer_id = get_layers_pre_post_behavior(layer_ids)\n        exposure_frames_by_layer_id = get_layers_exposure_frames(\n            layer_ids, layers\n        )\n        extraction_data_by_layer_id = calculate_layers_extraction_data(\n            layers,\n            exposure_frames_by_layer_id,\n            behavior_by_layer_id,\n            mark_in,\n            mark_out\n        )\n        # Render layers\n        filepaths_by_layer_id = {}\n        for layer_id, render_data in extraction_data_by_layer_id.items():\n            layer = layers_by_id[layer_id]\n            filepaths_by_layer_id[layer_id] = self._render_layer(\n                render_data, layer, output_dir, ignore_layer_opacity\n            )\n\n        # Prepare final filepaths where compositing should store result\n        output_filepaths_by_frame = {}\n        thumbnail_src_filepath = None\n        finale_template = get_frame_filename_template(mark_out)\n        for frame_idx in range(mark_in, mark_out + 1):\n            filename = finale_template.format(frame=frame_idx)\n\n            filepath = os.path.join(output_dir, filename)\n            output_filepaths_by_frame[frame_idx] = filepath\n\n            if thumbnail_src_filepath is None:\n                thumbnail_src_filepath = filepath\n\n        self.log.info(\"Started compositing of layer frames.\")\n        composite_rendered_layers(\n            layers, filepaths_by_layer_id,\n            mark_in, mark_out,\n            output_filepaths_by_frame\n        )\n\n        self.log.info(\"Compositing finished\")\n        thumbnail_filepath = None\n        if thumbnail_src_filepath and os.path.exists(thumbnail_src_filepath):\n            source_img = Image.open(thumbnail_src_filepath)\n            thumbnail_filepath = os.path.join(output_dir, \"thumbnail.jpg\")\n            # Composite background only on rgba images\n            # - just making sure\n            if source_img.mode.lower() == \"rgba\":\n                bg_color = self._get_review_bg_color()\n                self.log.debug(\"Adding thumbnail background color {}.\".format(\n                    \" \".join([str(val) for val in bg_color])\n                ))\n                bg_image = Image.new(\"RGBA\", source_img.size, bg_color)\n                thumbnail_obj = Image.alpha_composite(bg_image, source_img)\n                thumbnail_obj.convert(\"RGB\").save(thumbnail_filepath)\n\n            else:\n                self.log.info((\n                    \"Source for thumbnail has mode \\\"{}\\\" (Expected: RGBA).\"\n                    \" Can't use thumbnail background color.\"\n                ).format(source_img.mode))\n                source_img.save(thumbnail_filepath)\n\n        return output_filepaths_by_frame, thumbnail_filepath\n\n    def _get_review_bg_color(self):\n        red = green = blue = 255\n        if self.review_bg:\n            if len(self.review_bg) == 4:\n                red, green, blue, _ = self.review_bg\n            elif len(self.review_bg) == 3:\n                red, green, blue = self.review_bg\n        return (red, green, blue)\n\n    def _render_layer(\n        self, render_data, layer, output_dir, ignore_layer_opacity\n    ):\n        frame_references = render_data[\"frame_references\"]\n        filenames_by_frame_index = render_data[\"filenames_by_frame_index\"]\n\n        layer_id = layer[\"layer_id\"]\n        george_script_lines = [\n            \"tv_layerset {}\".format(layer_id),\n            \"tv_SaveMode \\\"PNG\\\"\"\n        ]\n        # Set density to 100 and store previous opacity\n        if ignore_layer_opacity:\n            george_script_lines.extend([\n                \"tv_layerdensity 100\",\n                \"orig_opacity = result\",\n            ])\n\n        filepaths_by_frame = {}\n        frames_to_render = []\n        for frame_idx, ref_idx in frame_references.items():\n            # None reference is skipped because does not have source\n            if ref_idx is None:\n                filepaths_by_frame[frame_idx] = None\n                continue\n            filename = filenames_by_frame_index[frame_idx]\n            dst_path = \"/\".join([output_dir, filename])\n            filepaths_by_frame[frame_idx] = dst_path\n            if frame_idx != ref_idx:\n                continue\n\n            frames_to_render.append(str(frame_idx))\n            # Go to frame\n            george_script_lines.append(\"tv_layerImage {}\".format(frame_idx))\n            # Store image to output\n            george_script_lines.append(\"tv_saveimage \\\"{}\\\"\".format(dst_path))\n\n        # Set density back to origin opacity\n        if ignore_layer_opacity:\n            george_script_lines.append(\"tv_layerdensity orig_opacity\")\n\n        self.log.debug(\"Rendering Exposure frames {} of layer {} ({})\".format(\n            \",\".join(frames_to_render), layer_id, layer[\"name\"]\n        ))\n        # Let TVPaint render layer's image\n        execute_george_through_file(\"\\n\".join(george_script_lines))\n\n        # Fill frames between `frame_start_index` and `frame_end_index`\n        self.log.debug(\"Filling frames not rendered frames.\")\n        fill_reference_frames(frame_references, filepaths_by_frame)\n\n        return filepaths_by_frame\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/extract_sequence.html#client.ayon_tvpaint.plugins.publish.extract_sequence.ExtractSequence.render","title":"<code>render(output_dir, mark_in, mark_out, layers, ignore_layer_opacity)</code>","text":"<p>Export images from TVPaint.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>Directory where files will be stored.</p> required <code>mark_in</code> <code>int</code> <p>Starting frame index from which export will begin.</p> required <code>mark_out</code> <code>int</code> <p>On which frame index export will end.</p> required <code>layers</code> <code>list</code> <p>List of layers to be exported.</p> required <code>ignore_layer_opacity</code> <code>bool</code> <p>Layer's opacity will be ignored.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>With 2 items first is list of filenames second is path to thumbnail.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/extract_sequence.py</code> <pre><code>def render(\n    self, output_dir, mark_in, mark_out, layers, ignore_layer_opacity\n):\n    \"\"\" Export images from TVPaint.\n\n    Args:\n        output_dir (str): Directory where files will be stored.\n        mark_in (int): Starting frame index from which export will begin.\n        mark_out (int): On which frame index export will end.\n        layers (list): List of layers to be exported.\n        ignore_layer_opacity (bool): Layer's opacity will be ignored.\n\n    Returns:\n        tuple: With 2 items first is list of filenames second is path to\n            thumbnail.\n    \"\"\"\n    self.log.debug(\"Preparing data for rendering.\")\n\n    # Map layers by position\n    layers_by_position = {}\n    layers_by_id = {}\n    layer_ids = []\n    for layer in layers:\n        layer_id = layer[\"layer_id\"]\n        position = layer[\"position\"]\n        layers_by_position[position] = layer\n        layers_by_id[layer_id] = layer\n\n        layer_ids.append(layer_id)\n\n    # Sort layer positions in reverse order\n    sorted_positions = list(reversed(sorted(layers_by_position.keys())))\n    if not sorted_positions:\n        return [], None\n\n    self.log.debug(\"Collecting pre/post behavior of individual layers.\")\n    behavior_by_layer_id = get_layers_pre_post_behavior(layer_ids)\n    exposure_frames_by_layer_id = get_layers_exposure_frames(\n        layer_ids, layers\n    )\n    extraction_data_by_layer_id = calculate_layers_extraction_data(\n        layers,\n        exposure_frames_by_layer_id,\n        behavior_by_layer_id,\n        mark_in,\n        mark_out\n    )\n    # Render layers\n    filepaths_by_layer_id = {}\n    for layer_id, render_data in extraction_data_by_layer_id.items():\n        layer = layers_by_id[layer_id]\n        filepaths_by_layer_id[layer_id] = self._render_layer(\n            render_data, layer, output_dir, ignore_layer_opacity\n        )\n\n    # Prepare final filepaths where compositing should store result\n    output_filepaths_by_frame = {}\n    thumbnail_src_filepath = None\n    finale_template = get_frame_filename_template(mark_out)\n    for frame_idx in range(mark_in, mark_out + 1):\n        filename = finale_template.format(frame=frame_idx)\n\n        filepath = os.path.join(output_dir, filename)\n        output_filepaths_by_frame[frame_idx] = filepath\n\n        if thumbnail_src_filepath is None:\n            thumbnail_src_filepath = filepath\n\n    self.log.info(\"Started compositing of layer frames.\")\n    composite_rendered_layers(\n        layers, filepaths_by_layer_id,\n        mark_in, mark_out,\n        output_filepaths_by_frame\n    )\n\n    self.log.info(\"Compositing finished\")\n    thumbnail_filepath = None\n    if thumbnail_src_filepath and os.path.exists(thumbnail_src_filepath):\n        source_img = Image.open(thumbnail_src_filepath)\n        thumbnail_filepath = os.path.join(output_dir, \"thumbnail.jpg\")\n        # Composite background only on rgba images\n        # - just making sure\n        if source_img.mode.lower() == \"rgba\":\n            bg_color = self._get_review_bg_color()\n            self.log.debug(\"Adding thumbnail background color {}.\".format(\n                \" \".join([str(val) for val in bg_color])\n            ))\n            bg_image = Image.new(\"RGBA\", source_img.size, bg_color)\n            thumbnail_obj = Image.alpha_composite(bg_image, source_img)\n            thumbnail_obj.convert(\"RGB\").save(thumbnail_filepath)\n\n        else:\n            self.log.info((\n                \"Source for thumbnail has mode \\\"{}\\\" (Expected: RGBA).\"\n                \" Can't use thumbnail background color.\"\n            ).format(source_img.mode))\n            source_img.save(thumbnail_filepath)\n\n    return output_filepaths_by_frame, thumbnail_filepath\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/extract_sequence.html#client.ayon_tvpaint.plugins.publish.extract_sequence.ExtractSequence.render_review","title":"<code>render_review(output_dir, mark_in, mark_out, scene_bg_color)</code>","text":"<p>Export images from TVPaint using <code>tv_savesequence</code> command.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>Directory where files will be stored.</p> required <code>mark_in</code> <code>int</code> <p>Starting frame index from which export will begin.</p> required <code>mark_out</code> <code>int</code> <p>On which frame index export will end.</p> required <code>scene_bg_color</code> <code>list</code> <p>Bg color set in scene. Result of george script command <code>tv_background</code>.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>With 2 items first is list of filenames second is path to thumbnail.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/extract_sequence.py</code> <pre><code>def render_review(\n    self, output_dir, mark_in, mark_out, scene_bg_color\n):\n    \"\"\" Export images from TVPaint using `tv_savesequence` command.\n\n    Args:\n        output_dir (str): Directory where files will be stored.\n        mark_in (int): Starting frame index from which export will begin.\n        mark_out (int): On which frame index export will end.\n        scene_bg_color (list): Bg color set in scene. Result of george\n            script command `tv_background`.\n\n    Returns:\n        tuple: With 2 items first is list of filenames second is path to\n            thumbnail.\n    \"\"\"\n    filename_template = get_frame_filename_template(mark_out)\n\n    self.log.debug(\"Preparing data for rendering.\")\n    first_frame_filepath = os.path.join(\n        output_dir,\n        filename_template.format(frame=mark_in)\n    )\n\n    bg_color = self._get_review_bg_color()\n\n    george_script_lines = [\n        # Change bg color to color from settings\n        \"tv_background \\\"color\\\" {} {} {}\".format(*bg_color),\n        \"tv_SaveMode \\\"PNG\\\"\",\n        \"export_path = \\\"{}\\\"\".format(\n            first_frame_filepath.replace(\"\\\\\", \"/\")\n        ),\n        \"tv_savesequence '\\\"'export_path'\\\"' {} {}\".format(\n            mark_in, mark_out\n        )\n    ]\n    if scene_bg_color:\n        # Change bg color back to previous scene bg color\n        _scene_bg_color = copy.deepcopy(scene_bg_color)\n        bg_type = _scene_bg_color.pop(0)\n        orig_color_command = [\n            \"tv_background\",\n            \"\\\"{}\\\"\".format(bg_type)\n        ]\n        orig_color_command.extend(_scene_bg_color)\n\n        george_script_lines.append(\" \".join(orig_color_command))\n\n    execute_george_through_file(\"\\n\".join(george_script_lines))\n\n    first_frame_filepath = None\n    output_filepaths_by_frame_idx = {}\n    for frame_idx in range(mark_in, mark_out + 1):\n        filename = filename_template.format(frame=frame_idx)\n        filepath = os.path.join(output_dir, filename)\n\n        output_filepaths_by_frame_idx[frame_idx] = filepath\n\n        if not os.path.exists(filepath):\n            raise KnownPublishError(\n                \"Output was not rendered. File was not found {}\".format(\n                    filepath\n                )\n            )\n\n        if first_frame_filepath is None:\n            first_frame_filepath = filepath\n\n    thumbnail_filepath = None\n    if first_frame_filepath and os.path.exists(first_frame_filepath):\n        thumbnail_filepath = os.path.join(output_dir, \"thumbnail.jpg\")\n        source_img = Image.open(first_frame_filepath)\n        if source_img.mode.lower() != \"rgb\":\n            source_img = source_img.convert(\"RGB\")\n        source_img.save(thumbnail_filepath)\n\n    return output_filepaths_by_frame_idx, thumbnail_filepath\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/increment_workfile_version.html","title":"increment_workfile_version","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/increment_workfile_version.html#client.ayon_tvpaint.plugins.publish.increment_workfile_version.IncrementWorkfileVersion","title":"<code>IncrementWorkfileVersion</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Increment current workfile version.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/increment_workfile_version.py</code> <pre><code>class IncrementWorkfileVersion(pyblish.api.ContextPlugin):\n    \"\"\"Increment current workfile version.\"\"\"\n\n    order = pyblish.api.IntegratorOrder + 1\n    label = \"Increment Workfile Version\"\n    optional = True\n    hosts = [\"tvpaint\"]\n\n    settings_category = \"tvpaint\"\n\n    def process(self, context):\n\n        assert all(result[\"success\"] for result in context.data[\"results\"]), (\n            \"Publishing not successful so version is not increased.\")\n\n        host = registered_host()\n        path = context.data[\"currentFile\"]\n        host.save_workfile(version_up(path))\n        self.log.info('Incrementing workfile version')\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_asset_name.html","title":"validate_asset_name","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_asset_name.html#client.ayon_tvpaint.plugins.publish.validate_asset_name.FixFolderPaths","title":"<code>FixFolderPaths</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the folder paths.</p> <p>Change instanace metadata in the workfile.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_asset_name.py</code> <pre><code>class FixFolderPaths(pyblish.api.Action):\n    \"\"\"Repair the folder paths.\n\n    Change instanace metadata in the workfile.\n    \"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n        context_folder_path = context.data[\"folderPath\"]\n        old_instance_items = list_instances()\n        new_instance_items = []\n        for instance_item in old_instance_items:\n            instance_folder_path = instance_item.get(\"folderPath\")\n            if (\n                instance_folder_path\n                and instance_folder_path != context_folder_path\n            ):\n                instance_item[\"folderPath\"] = context_folder_path\n            new_instance_items.append(instance_item)\n        write_instances(new_instance_items)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_asset_name.html#client.ayon_tvpaint.plugins.publish.validate_asset_name.ValidateAssetName","title":"<code>ValidateAssetName</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>ContextPlugin</code></p> <p>Validate folder path present on instance.</p> <p>Folder path on instance should be the same as context's.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_asset_name.py</code> <pre><code>class ValidateAssetName(\n    OptionalPyblishPluginMixin,\n    pyblish.api.ContextPlugin\n):\n    \"\"\"Validate folder path present on instance.\n\n    Folder path on instance should be the same as context's.\n    \"\"\"\n\n    label = \"Validate Folder Paths\"\n    order = pyblish.api.ValidatorOrder\n    hosts = [\"tvpaint\"]\n    actions = [FixFolderPaths]\n\n    settings_category = \"tvpaint\"\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n        context_folder_path = context.data[\"folderPath\"]\n        for instance in context:\n            folder_path = instance.data.get(\"folderPath\")\n            if folder_path and folder_path == context_folder_path:\n                continue\n\n            instance_label = (\n                instance.data.get(\"label\") or instance.data[\"name\"]\n            )\n\n            raise PublishXmlValidationError(\n                self,\n                (\n                    \"Different folder path on instance then context's.\"\n                    \" Instance \\\"{}\\\" has folder path: \\\"{}\\\"\"\n                    \" Context folder path is: \\\"{}\\\"\"\n                ).format(\n                    instance_label, folder_path, context_folder_path\n                ),\n                formatting_data={\n                    \"expected_folder\": context_folder_path,\n                    \"found_folder\": folder_path\n                }\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_duplicated_layer_names.html","title":"validate_duplicated_layer_names","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_duplicated_layer_names.html#client.ayon_tvpaint.plugins.publish.validate_duplicated_layer_names.ValidateLayersGroup","title":"<code>ValidateLayersGroup</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate layer names for publishing are unique for whole workfile.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_duplicated_layer_names.py</code> <pre><code>class ValidateLayersGroup(pyblish.api.InstancePlugin):\n    \"\"\"Validate layer names for publishing are unique for whole workfile.\"\"\"\n\n    label = \"Validate Duplicated Layers Names\"\n    order = pyblish.api.ValidatorOrder\n    families = [\"renderPass\"]\n\n    settings_category = \"tvpaint\"\n\n    def process(self, instance):\n        # Prepare layers\n        layers_by_name = instance.context.data[\"layersByName\"]\n\n        # Layers ids of an instance\n        layer_names = instance.data[\"layer_names\"]\n\n        # Check if all layers from render pass are in right group\n        duplicated_layer_names = []\n        for layer_name in layer_names:\n            layers = layers_by_name.get(layer_name)\n            # It is not job of this validator to handle missing layers\n            if layers is None:\n                continue\n            if len(layers) &gt; 1:\n                duplicated_layer_names.append(layer_name)\n\n        # Everything is OK and skip exception\n        if not duplicated_layer_names:\n            return\n\n        layers_msg = \", \".join([\n            \"\\\"{}\\\"\".format(layer_name)\n            for layer_name in duplicated_layer_names\n        ])\n        detail_lines = [\n            \"- {}\".format(layer_name)\n            for layer_name in set(duplicated_layer_names)\n        ]\n        raise PublishXmlValidationError(\n            self,\n            (\n                \"Layers have duplicated names for instance {}.\"\n                # Description what's wrong\n                \" There are layers with same name and one of them is marked\"\n                \" for publishing so it is not possible to know which should\"\n                \" be published. Please look for layers with names: {}\"\n            ).format(instance.data[\"label\"], layers_msg),\n            formatting_data={\n                \"layer_names\": \"&lt;br/&gt;\".join(detail_lines)\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_layers_visibility.html","title":"validate_layers_visibility","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_layers_visibility.html#client.ayon_tvpaint.plugins.publish.validate_layers_visibility.ValidateLayersVisiblity","title":"<code>ValidateLayersVisiblity</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate existence of renderPass layers.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_layers_visibility.py</code> <pre><code>class ValidateLayersVisiblity(pyblish.api.InstancePlugin):\n    \"\"\"Validate existence of renderPass layers.\"\"\"\n\n    label = \"Validate Layers Visibility\"\n    order = pyblish.api.ValidatorOrder\n    families = [\"review\", \"render\"]\n\n    settings_category = \"tvpaint\"\n\n    def process(self, instance):\n        layers = instance.data.get(\"layers\")\n        # Instance have empty layers\n        # - it is not job of this validator to check that\n        if not layers:\n            return\n        layer_names = set()\n        for layer in layers:\n            layer_names.add(layer[\"name\"])\n            if layer[\"visible\"]:\n                return\n\n        instance_label = (\n            instance.data.get(\"label\") or instance.data[\"name\"]\n        )\n\n        raise PublishXmlValidationError(\n            self,\n            \"All layers of instance \\\"{}\\\" are not visible.\".format(\n                instance_label\n            ),\n            formatting_data={\n                \"instance_name\": instance_label,\n                \"layer_names\": \"&lt;br/&gt;\".join([\n                    \"- {}\".format(layer_name)\n                    for layer_name in layer_names\n                ])\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_marks.html","title":"validate_marks","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_marks.html#client.ayon_tvpaint.plugins.publish.validate_marks.ValidateMarks","title":"<code>ValidateMarks</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>ContextPlugin</code></p> <p>Validate mark in and out are enabled and it's duration.</p> <p>Mark In/Out does not have to match frameStart and frameEnd but duration is important.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_marks.py</code> <pre><code>class ValidateMarks(\n    OptionalPyblishPluginMixin,\n    pyblish.api.ContextPlugin\n):\n    \"\"\"Validate mark in and out are enabled and it's duration.\n\n    Mark In/Out does not have to match frameStart and frameEnd but duration is\n    important.\n    \"\"\"\n\n    label = \"Validate Mark In/Out\"\n    order = pyblish.api.ValidatorOrder\n    optional = True\n    actions = [ValidateMarksRepair]\n\n    settings_category = \"tvpaint\"\n\n    @staticmethod\n    def get_expected_data(context):\n        scene_mark_in = context.data[\"sceneMarkIn\"]\n\n        # Data collected in `CollectContextEntities`\n        frame_end = context.data[\"frameEnd\"]\n        frame_start = context.data[\"frameStart\"]\n        handle_start = context.data[\"handleStart\"]\n        handle_end = context.data[\"handleEnd\"]\n\n        # Calculate expected Mark out (Mark In + duration - 1)\n        expected_mark_out = (\n            scene_mark_in\n            + (frame_end - frame_start)\n            + handle_start + handle_end\n        )\n        return {\n            \"markIn\": scene_mark_in,\n            \"markInState\": True,\n            \"markOut\": expected_mark_out,\n            \"markOutState\": True\n        }\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        current_data = {\n            \"markIn\": context.data[\"sceneMarkIn\"],\n            \"markInState\": context.data[\"sceneMarkInState\"],\n            \"markOut\": context.data[\"sceneMarkOut\"],\n            \"markOutState\": context.data[\"sceneMarkOutState\"]\n        }\n        expected_data = self.get_expected_data(context)\n        invalid = {}\n        for k in current_data.keys():\n            if current_data[k] != expected_data[k]:\n                invalid[k] = {\n                    \"current\": current_data[k],\n                    \"expected\": expected_data[k]\n                }\n\n        # Validation ends\n        if not invalid:\n            return\n\n        current_frame_range = (\n            (current_data[\"markOut\"] - current_data[\"markIn\"]) + 1\n        )\n        expected_frame_range = (\n            (expected_data[\"markOut\"] - expected_data[\"markIn\"]) + 1\n        )\n        mark_in_enable_state = \"disabled\"\n        if current_data[\"markInState\"]:\n            mark_in_enable_state = \"enabled\"\n\n        mark_out_enable_state = \"disabled\"\n        if current_data[\"markOutState\"]:\n            mark_out_enable_state = \"enabled\"\n\n        raise PublishXmlValidationError(\n            self,\n            \"Marks does not match database:\\n{}\".format(\n                json.dumps(invalid, sort_keys=True, indent=4)\n            ),\n            formatting_data={\n                \"current_frame_range\": str(current_frame_range),\n                \"expected_frame_range\": str(expected_frame_range),\n                \"mark_in_enable_state\": mark_in_enable_state,\n                \"mark_out_enable_state\": mark_out_enable_state,\n                \"expected_mark_out\": expected_data[\"markOut\"]\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_marks.html#client.ayon_tvpaint.plugins.publish.validate_marks.ValidateMarksRepair","title":"<code>ValidateMarksRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair the marks.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_marks.py</code> <pre><code>class ValidateMarksRepair(pyblish.api.Action):\n    \"\"\"Repair the marks.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n        expected_data = ValidateMarks.get_expected_data(context)\n\n        execute_george(\n            \"tv_markin {} set\".format(expected_data[\"markIn\"])\n        )\n        execute_george(\n            \"tv_markout {} set\".format(expected_data[\"markOut\"])\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_missing_layer_names.html","title":"validate_missing_layer_names","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_missing_layer_names.html#client.ayon_tvpaint.plugins.publish.validate_missing_layer_names.ValidateMissingLayers","title":"<code>ValidateMissingLayers</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate existence of renderPass layers.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_missing_layer_names.py</code> <pre><code>class ValidateMissingLayers(pyblish.api.InstancePlugin):\n    \"\"\"Validate existence of renderPass layers.\"\"\"\n\n    label = \"Validate Missing Layers Names\"\n    order = pyblish.api.ValidatorOrder\n    families = [\"renderPass\"]\n\n    settings_category = \"tvpaint\"\n\n    def process(self, instance):\n        # Prepare layers\n        layers_by_name = instance.context.data[\"layersByName\"]\n\n        # Layers ids of an instance\n        layer_names = instance.data[\"layer_names\"]\n\n        # Check if all layers from render pass are in right group\n        missing_layer_names = []\n        for layer_name in layer_names:\n            layers = layers_by_name.get(layer_name)\n            if not layers:\n                missing_layer_names.append(layer_name)\n\n        # Everything is OK and skip exception\n        if not missing_layer_names:\n            return\n\n        layers_msg = \", \".join([\n            \"\\\"{}\\\"\".format(layer_name)\n            for layer_name in missing_layer_names\n        ])\n        instance_label = (\n            instance.data.get(\"label\") or instance.data[\"name\"]\n        )\n        description_layer_names = \"&lt;br/&gt;\".join([\n            \"- {}\".format(layer_name)\n            for layer_name in missing_layer_names\n        ])\n\n        # Raise an error\n        raise PublishXmlValidationError(\n            self,\n            (\n                \"Layers were not found by name for instance \\\"{}\\\".\"\n                # Description what's wrong\n                \" Layer names marked for publishing are not available\"\n                \" in layers list. Missing layer names: {}\"\n            ).format(instance.data[\"label\"], layers_msg),\n            formatting_data={\n                \"instance_name\": instance_label,\n                \"layer_names\": description_layer_names\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_render_layer_group.html","title":"validate_render_layer_group","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_render_layer_group.html#client.ayon_tvpaint.plugins.publish.validate_render_layer_group.ValidateRenderLayerGroups","title":"<code>ValidateRenderLayerGroups</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Validate group ids of renderLayer products.</p> <p>Validate that there are not 2 render layers using the same group.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_render_layer_group.py</code> <pre><code>class ValidateRenderLayerGroups(pyblish.api.ContextPlugin):\n    \"\"\"Validate group ids of renderLayer products.\n\n    Validate that there are not 2 render layers using the same group.\n    \"\"\"\n\n    label = \"Validate Render Layers Group\"\n    order = pyblish.api.ValidatorOrder + 0.1\n\n    settings_category = \"tvpaint\"\n\n    def process(self, context):\n        # Prepare layers\n        render_layers_by_group_id = collections.defaultdict(list)\n        for instance in context:\n            families = instance.data.get(\"families\")\n            if not families or \"renderLayer\" not in families:\n                continue\n\n            group_id = instance.data[\"creator_attributes\"][\"group_id\"]\n            render_layers_by_group_id[group_id].append(instance)\n\n        duplicated_instances = []\n        for group_id, instances in render_layers_by_group_id.items():\n            if len(instances) &gt; 1:\n                duplicated_instances.append((group_id, instances))\n\n        if not duplicated_instances:\n            return\n\n        # Exception message preparations\n        groups_data = context.data[\"groupsData\"]\n        groups_by_id = {\n            group[\"group_id\"]: group\n            for group in groups_data\n        }\n\n        per_group_msgs = []\n        groups_information_lines = []\n        for group_id, instances in duplicated_instances:\n            group = groups_by_id[group_id]\n            group_label = \"Group \\\"{}\\\" ({})\".format(\n                group[\"name\"],\n                group[\"group_id\"],\n            )\n            line_join_product_names = \"\\n\".join([\n                f\"    - {instance['productName']}\"\n                for instance in instances\n            ])\n            joined_product_names = \", \".join([\n                f\"\\\"{instance['productName']}\\\"\"\n                for instance in instances\n            ])\n            per_group_msgs.append(\n                \"{} &lt; {} &gt;\".format(group_label, joined_product_names)\n            )\n            groups_information_lines.append(\n                \"&lt;b&gt;{}&lt;/b&gt;\\n{}\".format(\n                    group_label, line_join_product_names\n                )\n            )\n\n        # Raise an error\n        raise PublishXmlValidationError(\n            self,\n            (\n                \"More than one Render Layer is using the same TVPaint\"\n                \" group color. {}\"\n            ).format(\" | \".join(per_group_msgs)),\n            formatting_data={\n                \"groups_information\": \"\\n\".join(groups_information_lines)\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_render_pass_group.html","title":"validate_render_pass_group","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_render_pass_group.html#client.ayon_tvpaint.plugins.publish.validate_render_pass_group.ValidateLayersGroup","title":"<code>ValidateLayersGroup</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate group ids of renderPass layers.</p> <p>Validates that all layers are in same group as they were during creation.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_render_pass_group.py</code> <pre><code>class ValidateLayersGroup(pyblish.api.InstancePlugin):\n    \"\"\"Validate group ids of renderPass layers.\n\n    Validates that all layers are in same group as they were during creation.\n    \"\"\"\n\n    label = \"Validate Layers Group\"\n    order = pyblish.api.ValidatorOrder + 0.1\n    families = [\"renderPass\"]\n\n    settings_category = \"tvpaint\"\n\n    def process(self, instance):\n        # Prepare layers\n        layers_data = instance.context.data[\"layersData\"]\n        layers_by_name = {\n            layer[\"name\"]: layer\n            for layer in layers_data\n        }\n\n        # Expected group id for instance layers\n        group_id = instance.data[\"group_id\"]\n        # Layers ids of an instance\n        layer_names = instance.data[\"layer_names\"]\n        # Check if all layers from render pass are in right group\n        invalid_layers_by_group_id = collections.defaultdict(list)\n        invalid_layer_names = set()\n        for layer_name in layer_names:\n            layer = layers_by_name.get(layer_name)\n            _group_id = layer[\"group_id\"]\n            if _group_id != group_id:\n                invalid_layers_by_group_id[_group_id].append(layer)\n                invalid_layer_names.add(layer_name)\n\n        # Everything is OK and skip exception\n        if not invalid_layers_by_group_id:\n            return\n\n        # Exception message preparations\n        groups_data = instance.context.data[\"groupsData\"]\n        groups_by_id = {\n            group[\"group_id\"]: group\n            for group in groups_data\n        }\n        correct_group = groups_by_id[group_id]\n\n        per_group_msgs = []\n        for _group_id, layers in invalid_layers_by_group_id.items():\n            _group = groups_by_id[_group_id]\n            layers_msgs = []\n            for layer in layers:\n                layers_msgs.append(\n                    \"\\\"{}\\\" (id: {})\".format(layer[\"name\"], layer[\"layer_id\"])\n                )\n            per_group_msgs.append(\n                \"Group \\\"{}\\\" (id: {}) &lt; {} &gt;\".format(\n                    _group[\"name\"],\n                    _group[\"group_id\"],\n                    \", \".join(layers_msgs)\n                )\n            )\n\n        # Raise an error\n        raise PublishXmlValidationError(\n            self,\n            (\n                # Short message\n                \"Layers in wrong group.\"\n                # Description what's wrong\n                \" Layers from render pass \\\"{}\\\" must be in group {} (id: {}).\"\n                # Detailed message\n                \" Layers in wrong group: {}\"\n            ).format(\n                instance.data[\"label\"],\n                correct_group[\"name\"],\n                correct_group[\"group_id\"],\n                \" | \".join(per_group_msgs)\n            ),\n            formatting_data={\n                \"instance_name\": (\n                    instance.data.get(\"label\") or instance.data[\"name\"]\n                ),\n                \"expected_group\": correct_group[\"name\"],\n                \"layer_names\": \", \".join(invalid_layer_names)\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_scene_settings.html","title":"validate_scene_settings","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_scene_settings.html#client.ayon_tvpaint.plugins.publish.validate_scene_settings.ValidateProjectSettings","title":"<code>ValidateProjectSettings</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>ContextPlugin</code></p> <p>Validate scene settings against database.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_scene_settings.py</code> <pre><code>class ValidateProjectSettings(\n    OptionalPyblishPluginMixin,\n    pyblish.api.ContextPlugin\n):\n    \"\"\"Validate scene settings against database.\"\"\"\n\n    label = \"Validate Scene Settings\"\n    order = pyblish.api.ValidatorOrder\n\n    settings_category = \"tvpaint\"\n    optional = True\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        task_attributes = context.data[\"taskEntity\"][\"attrib\"]\n        scene_data = {\n            \"fps\": context.data.get(\"sceneFps\"),\n            \"resolutionWidth\": context.data.get(\"sceneWidth\"),\n            \"resolutionHeight\": context.data.get(\"sceneHeight\"),\n            \"pixelAspect\": context.data.get(\"scenePixelAspect\")\n        }\n        invalid = {}\n        for k in scene_data.keys():\n            expected_value = task_attributes[k]\n            if scene_data[k] != expected_value:\n                invalid[k] = {\n                    \"current\": scene_data[k], \"expected\": expected_value\n                }\n\n        if not invalid:\n            return\n\n        raise PublishXmlValidationError(\n            self,\n            \"Scene settings does not match database:\\n{}\".format(\n                json.dumps(invalid, sort_keys=True, indent=4)\n            ),\n            formatting_data={\n                \"expected_fps\": task_attributes[\"fps\"],\n                \"current_fps\": scene_data[\"fps\"],\n                \"expected_width\": task_attributes[\"resolutionWidth\"],\n                \"expected_height\": task_attributes[\"resolutionHeight\"],\n                \"current_width\": scene_data[\"resolutionWidth\"],\n                \"current_height\": scene_data[\"resolutionHeight\"],\n                \"expected_pixel_ratio\": task_attributes[\"pixelAspect\"],\n                \"current_pixel_ratio\": scene_data[\"pixelAspect\"]\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_start_frame.html","title":"validate_start_frame","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_start_frame.html#client.ayon_tvpaint.plugins.publish.validate_start_frame.RepairStartFrame","title":"<code>RepairStartFrame</code>","text":"<p>               Bases: <code>Action</code></p> <p>Repair start frame.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_start_frame.py</code> <pre><code>class RepairStartFrame(pyblish.api.Action):\n    \"\"\"Repair start frame.\"\"\"\n\n    label = \"Repair\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, plugin):\n        execute_george(\"tv_startframe 0\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_start_frame.html#client.ayon_tvpaint.plugins.publish.validate_start_frame.ValidateStartFrame","title":"<code>ValidateStartFrame</code>","text":"<p>               Bases: <code>OptionalPyblishPluginMixin</code>, <code>ContextPlugin</code></p> <p>Validate start frame being at frame 0.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_start_frame.py</code> <pre><code>class ValidateStartFrame(\n    OptionalPyblishPluginMixin,\n    pyblish.api.ContextPlugin\n):\n    \"\"\"Validate start frame being at frame 0.\"\"\"\n\n    label = \"Validate Start Frame\"\n    order = pyblish.api.ValidatorOrder\n    hosts = [\"tvpaint\"]\n    actions = [RepairStartFrame]\n\n    settings_category = \"tvpaint\"\n    optional = True\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        start_frame = execute_george(\"tv_startframe\")\n        if start_frame == 0:\n            return\n\n        raise PublishXmlValidationError(\n            self,\n            \"Start frame has to be frame 0.\",\n            formatting_data={\n                \"current_start_frame\": start_frame\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_workfile_metadata.html","title":"validate_workfile_metadata","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_workfile_metadata.html#client.ayon_tvpaint.plugins.publish.validate_workfile_metadata.ValidateWorkfileMetadata","title":"<code>ValidateWorkfileMetadata</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Validate if wokrfile contain required metadata for publising.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_workfile_metadata.py</code> <pre><code>class ValidateWorkfileMetadata(pyblish.api.ContextPlugin):\n    \"\"\"Validate if wokrfile contain required metadata for publising.\"\"\"\n\n    label = \"Validate Workfile Metadata\"\n    order = pyblish.api.ValidatorOrder\n\n    families = [\"workfile\"]\n\n    actions = [ValidateWorkfileMetadataRepair]\n\n    settings_category = \"tvpaint\"\n\n    required_keys = {\"project_name\", \"folder_path\", \"task_name\"}\n\n    def process(self, context):\n        workfile_context = context.data[\"workfile_context\"]\n        if not workfile_context:\n            raise PublishValidationError(\n                \"Current workfile is missing whole metadata about context.\",\n                \"Missing context\",\n                (\n                    \"Current workfile is missing metadata about task.\"\n                    \" To fix this issue save the file using Workfiles tool.\"\n                )\n            )\n\n        missing_keys = []\n        for key in self.required_keys:\n            value = workfile_context.get(key)\n            if not value:\n                missing_keys.append(key)\n\n        if missing_keys:\n            raise PublishXmlValidationError(\n                self,\n                \"Current workfile is missing metadata about {}.\".format(\n                    \", \".join(missing_keys)\n                ),\n                formatting_data={\n                    \"missing_metadata\": \", \".join(missing_keys)\n                }\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_workfile_metadata.html#client.ayon_tvpaint.plugins.publish.validate_workfile_metadata.ValidateWorkfileMetadataRepair","title":"<code>ValidateWorkfileMetadataRepair</code>","text":"<p>               Bases: <code>Action</code></p> <p>Store current context into workfile metadata.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_workfile_metadata.py</code> <pre><code>class ValidateWorkfileMetadataRepair(pyblish.api.Action):\n    \"\"\"Store current context into workfile metadata.\"\"\"\n\n    label = \"Use current context\"\n    icon = \"wrench\"\n    on = \"failed\"\n\n    def process(self, context, _plugin):\n        \"\"\"Save current workfile which should trigger storing of metadata.\"\"\"\n        current_file = context.data[\"currentFile\"]\n        host = registered_host()\n        # Save file should trigger\n        host.save_workfile(current_file)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_workfile_metadata.html#client.ayon_tvpaint.plugins.publish.validate_workfile_metadata.ValidateWorkfileMetadataRepair.process","title":"<code>process(context, _plugin)</code>","text":"<p>Save current workfile which should trigger storing of metadata.</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_workfile_metadata.py</code> <pre><code>def process(self, context, _plugin):\n    \"\"\"Save current workfile which should trigger storing of metadata.\"\"\"\n    current_file = context.data[\"currentFile\"]\n    host = registered_host()\n    # Save file should trigger\n    host.save_workfile(current_file)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_workfile_project_name.html","title":"validate_workfile_project_name","text":""},{"location":"autoapi/client/ayon_tvpaint/plugins/publish/validate_workfile_project_name.html#client.ayon_tvpaint.plugins.publish.validate_workfile_project_name.ValidateWorkfileProjectName","title":"<code>ValidateWorkfileProjectName</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Validate project name stored in workfile metadata.</p> <p>It is not possible to publish from different project than is set in environment variable \"AYON_PROJECT_NAME\".</p> Source code in <code>client/ayon_tvpaint/plugins/publish/validate_workfile_project_name.py</code> <pre><code>class ValidateWorkfileProjectName(pyblish.api.ContextPlugin):\n    \"\"\"Validate project name stored in workfile metadata.\n\n    It is not possible to publish from different project than is set in\n    environment variable \"AYON_PROJECT_NAME\".\n    \"\"\"\n\n    label = \"Validate Workfile Project Name\"\n    order = pyblish.api.ValidatorOrder\n\n    settings_category = \"tvpaint\"\n\n    def process(self, context):\n        workfile_context = context.data.get(\"workfile_context\")\n        # If workfile context is missing than project is matching to\n        #   global project\n        if not workfile_context:\n            self.log.info(\n                \"Workfile context (\\\"workfile_context\\\") is not filled.\"\n            )\n            return\n\n        workfile_project_name = workfile_context[\"project_name\"]\n        env_project_name = context.data[\"projectName\"]\n        if workfile_project_name == env_project_name:\n            self.log.info((\n                \"Both workfile project and environment project are same. {}\"\n            ).format(env_project_name))\n            return\n\n        # Raise an error\n        raise PublishXmlValidationError(\n            self,\n            (\n                # Short message\n                \"Workfile from different Project ({}).\"\n                # Description what's wrong\n                \" It is not possible to publish when TVPaint was launched in\"\n                \"context of different project. Current context project is\"\n                \" \\\"{}\\\". Launch TVPaint in context of project \\\"{}\\\"\"\n                \" and then publish.\"\n            ).format(\n                workfile_project_name,\n                env_project_name,\n                workfile_project_name,\n            ),\n            formatting_data={\n                \"workfile_project_name\": workfile_project_name,\n                \"expected_project_name\": env_project_name\n            }\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/tvpaint_plugin/index.html","title":"tvpaint_plugin","text":""},{"location":"autoapi/client/ayon_tvpaint/worker/index.html","title":"worker","text":""},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.CollectSceneData","title":"<code>CollectSceneData</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Helper command which will collect all useful info about workfile.</p> <p>Result is dictionary with all layers data, exposure frames by layer ids pre/post behavior of layers by their ids, group information and scene data.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class CollectSceneData(BaseCommand):\n    \"\"\"Helper command which will collect all useful info about workfile.\n\n    Result is dictionary with all layers data, exposure frames by layer ids\n    pre/post behavior of layers by their ids, group information and scene data.\n    \"\"\"\n    name = \"collect_scene_data\"\n\n    def execute(self):\n        from ayon_tvpaint.api.lib import (\n            get_layers_data,\n            get_groups_data,\n            get_layers_pre_post_behavior,\n            get_layers_exposure_frames,\n            get_scene_data\n        )\n\n        groups_data = get_groups_data(communicator=self.communicator)\n        layers_data = get_layers_data(communicator=self.communicator)\n        layer_ids = [\n            layer_data[\"layer_id\"]\n            for layer_data in layers_data\n        ]\n        pre_post_beh_by_layer_id = get_layers_pre_post_behavior(\n            layer_ids, communicator=self.communicator\n        )\n        exposure_frames_by_layer_id = get_layers_exposure_frames(\n            layer_ids, layers_data, communicator=self.communicator\n        )\n\n        self._result = {\n            \"layers_data\": layers_data,\n            \"exposure_frames_by_layer_id\": exposure_frames_by_layer_id,\n            \"pre_post_beh_by_layer_id\": pre_post_beh_by_layer_id,\n            \"groups_data\": groups_data,\n            \"scene_data\": get_scene_data(self.communicator)\n        }\n\n    @classmethod\n    def from_existing(cls, data):\n        return cls(data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ExecuteGeorgeScript","title":"<code>ExecuteGeorgeScript</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Execute multiline george script in TVPaint.</p> <p>Parameters:</p> Name Type Description Default <code>script_lines(list)</code> <p>Lines that will be executed in george script through temp george file.</p> required <code>tmp_file_keys(list)</code> <p>List of formatting keys in george script that require replacement with path to a temp file where result will be stored. The content of file is stored to result by the key.</p> required <code>root_dir_key(str)</code> <p>Formatting key that will be replaced in george script with job queue root which can be different on worker side.</p> required <code>data(dict)</code> <p>Raw data about command.</p> required Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class ExecuteGeorgeScript(BaseCommand):\n    \"\"\"Execute multiline george script in TVPaint.\n\n    Args:\n        script_lines(list): Lines that will be executed in george script\n            through temp george file.\n        tmp_file_keys(list): List of formatting keys in george script that\n            require replacement with path to a temp file where result will be\n            stored. The content of file is stored to result by the key.\n        root_dir_key(str): Formatting key that will be replaced in george\n            script with job queue root which can be different on worker side.\n        data(dict): Raw data about command.\n    \"\"\"\n    name = \"execute_george_through_file\"\n\n    def __init__(\n        self, script_lines, tmp_file_keys=None, root_dir_key=None, data=None\n    ):\n        data = data or {}\n        if not tmp_file_keys:\n            tmp_file_keys = data.get(\"tmp_file_keys\") or []\n\n        data[\"script_lines\"] = script_lines\n        data[\"tmp_file_keys\"] = tmp_file_keys\n        data[\"root_dir_key\"] = root_dir_key\n        self._script_lines = script_lines\n        self._tmp_file_keys = tmp_file_keys\n        self._root_dir_key = root_dir_key\n        super().__init__(data)\n\n    def execute(self):\n        filepath_by_key = {}\n        script = self._script_lines\n        if isinstance(script, list):\n            script = \"\\n\".join(script)\n\n        # Replace temporary files in george script\n        for key in self._tmp_file_keys:\n            output_file = tempfile.NamedTemporaryFile(\n                mode=\"w\", prefix=TMP_FILE_PREFIX, suffix=\".txt\", delete=False\n            )\n            output_file.close()\n            format_key = \"{\" + key + \"}\"\n            output_path = output_file.name.replace(\"\\\\\", \"/\")\n            script = script.replace(format_key, output_path)\n            filepath_by_key[key] = output_path\n\n        # Replace job queue root in script\n        if self._root_dir_key:\n            job_queue_root = self.job_queue_root()\n            format_key = \"{\" + self._root_dir_key + \"}\"\n            script = script.replace(\n                format_key, job_queue_root.replace(\"\\\\\", \"/\")\n            )\n\n        # Execute the script\n        self.execute_george_through_file(script)\n\n        # Store result of temporary files\n        result = {}\n        for key, filepath in filepath_by_key.items():\n            with open(filepath, \"r\") as stream:\n                data = stream.read()\n            result[key] = data\n            os.remove(filepath)\n\n        self._result = result\n\n    @classmethod\n    def from_existing(cls, data):\n        \"\"\"Recreate the object from data.\"\"\"\n        script_lines = data.pop(\"script_lines\")\n        tmp_file_keys = data.pop(\"tmp_file_keys\", None)\n        root_dir_key = data.pop(\"root_dir_key\", None)\n        return cls(script_lines, tmp_file_keys, root_dir_key, data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ExecuteGeorgeScript.from_existing","title":"<code>from_existing(data)</code>  <code>classmethod</code>","text":"<p>Recreate the object from data.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>@classmethod\ndef from_existing(cls, data):\n    \"\"\"Recreate the object from data.\"\"\"\n    script_lines = data.pop(\"script_lines\")\n    tmp_file_keys = data.pop(\"tmp_file_keys\", None)\n    root_dir_key = data.pop(\"root_dir_key\", None)\n    return cls(script_lines, tmp_file_keys, root_dir_key, data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ExecuteSimpleGeorgeScript","title":"<code>ExecuteSimpleGeorgeScript</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Execute simple george script in TVPaint.</p> <p>Parameters:</p> Name Type Description Default <code>script(str)</code> <p>Script that will be executed.</p> required Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class ExecuteSimpleGeorgeScript(BaseCommand):\n    \"\"\"Execute simple george script in TVPaint.\n\n    Args:\n        script(str): Script that will be executed.\n    \"\"\"\n    name = \"execute_george_simple\"\n\n    def __init__(self, script, data=None):\n        data = data or {}\n        data[\"script\"] = script\n        self._script = script\n        super().__init__(data)\n\n    def execute(self):\n        self._result = self.execute_george(self._script)\n\n    @classmethod\n    def from_existing(cls, data):\n        script = data.pop(\"script\")\n        return cls(script, data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.JobFailed","title":"<code>JobFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when job was sent and finished unsuccessfully.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class JobFailed(Exception):\n    \"\"\"Raised when job was sent and finished unsuccessfully.\"\"\"\n    def __init__(self, job_status):\n        job_state = job_status[\"state\"]\n        job_message = job_status[\"message\"] or \"Unknown issue\"\n        error_msg = (\n            \"Job didn't finish properly.\"\n            \" Job state: \\\"{}\\\" | Job message: \\\"{}\\\"\"\n        ).format(job_state, job_message)\n\n        self.job_status = job_status\n\n        super().__init__(error_msg)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ProcessTVPaintCommands","title":"<code>ProcessTVPaintCommands</code>","text":"<p>               Bases: <code>TVPaintCommands</code></p> <p>Worker side of TVPaint Commands.</p> <p>It is expected this object is created only on worker's side from existing data loaded from job.</p> <p>Workfile path logic is based on 'SenderTVPaintCommands'.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class ProcessTVPaintCommands(TVPaintCommands):\n    \"\"\"Worker side of TVPaint Commands.\n\n    It is expected this object is created only on worker's side from existing\n    data loaded from job.\n\n    Workfile path logic is based on 'SenderTVPaintCommands'.\n    \"\"\"\n    def __init__(self, workfile, commands, communicator):\n        super(ProcessTVPaintCommands, self).__init__(workfile)\n\n        self._communicator = communicator\n\n        self.commands_from_data(commands)\n\n    def _prepare_workfile(self, workfile):\n        \"\"\"Preprend job queue root before passed workfile.\"\"\"\n        workfile = workfile.replace(\"\\\\\", \"/\")\n        job_queue_root = self.job_queue_root().replace(\"\\\\\", \"/\")\n        new_workfile = \"/\".join([job_queue_root, workfile])\n        while \"//\" in new_workfile:\n            new_workfile = new_workfile.replace(\"//\", \"/\")\n        return os.path.normpath(new_workfile)\n\n    @property\n    def communicator(self):\n        \"\"\"Access to TVPaint communicator.\"\"\"\n        return self._communicator\n\n    def commands_from_data(self, commands_data):\n        \"\"\"Recreate command from passed data.\"\"\"\n        for command_data in commands_data:\n            command_name = command_data[\"command\"]\n\n            klass = self.classes_by_name[command_name]\n            command = klass.from_existing(command_data)\n            self.add_command(command)\n\n    def execute_george(self, george_script):\n        \"\"\"Helper method to execute george script.\"\"\"\n        return self.communicator.execute_george(george_script)\n\n    def execute_george_through_file(self, george_script):\n        \"\"\"Helper method to execute george script through temp file.\"\"\"\n        temporary_file = tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=TMP_FILE_PREFIX, suffix=\".grg\", delete=False\n        )\n        temporary_file.write(george_script)\n        temporary_file.close()\n        temp_file_path = temporary_file.name.replace(\"\\\\\", \"/\")\n        self.execute_george(\"tv_runscript {}\".format(temp_file_path))\n        os.remove(temp_file_path)\n\n    def _open_workfile(self):\n        \"\"\"Open workfile in TVPaint.\"\"\"\n        workfile = self._workfile\n        print(\"Opening workfile {}\".format(workfile))\n        george_script = \"tv_LoadProject '\\\"'\\\"{}\\\"'\\\"'\".format(workfile)\n        self.execute_george_through_file(george_script)\n\n    def _close_workfile(self):\n        \"\"\"Close workfile in TVPaint.\"\"\"\n        print(\"Closing workfile\")\n        self.execute_george_through_file(\"tv_projectclose\")\n\n    def execute(self):\n        \"\"\"Execute commands.\"\"\"\n        # First open the workfile\n        self._open_workfile()\n        # Execute commands one by one\n        # TODO maybe stop processing when command fails?\n        print(\"Commands execution started ({})\".format(len(self._commands)))\n        for command in self._commands:\n            command.execute()\n            command.set_done()\n        # Finally close workfile\n        self._close_workfile()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ProcessTVPaintCommands.communicator","title":"<code>communicator</code>  <code>property</code>","text":"<p>Access to TVPaint communicator.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ProcessTVPaintCommands.commands_from_data","title":"<code>commands_from_data(commands_data)</code>","text":"<p>Recreate command from passed data.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def commands_from_data(self, commands_data):\n    \"\"\"Recreate command from passed data.\"\"\"\n    for command_data in commands_data:\n        command_name = command_data[\"command\"]\n\n        klass = self.classes_by_name[command_name]\n        command = klass.from_existing(command_data)\n        self.add_command(command)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ProcessTVPaintCommands.execute","title":"<code>execute()</code>","text":"<p>Execute commands.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def execute(self):\n    \"\"\"Execute commands.\"\"\"\n    # First open the workfile\n    self._open_workfile()\n    # Execute commands one by one\n    # TODO maybe stop processing when command fails?\n    print(\"Commands execution started ({})\".format(len(self._commands)))\n    for command in self._commands:\n        command.execute()\n        command.set_done()\n    # Finally close workfile\n    self._close_workfile()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ProcessTVPaintCommands.execute_george","title":"<code>execute_george(george_script)</code>","text":"<p>Helper method to execute george script.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def execute_george(self, george_script):\n    \"\"\"Helper method to execute george script.\"\"\"\n    return self.communicator.execute_george(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.ProcessTVPaintCommands.execute_george_through_file","title":"<code>execute_george_through_file(george_script)</code>","text":"<p>Helper method to execute george script through temp file.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def execute_george_through_file(self, george_script):\n    \"\"\"Helper method to execute george script through temp file.\"\"\"\n    temporary_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=TMP_FILE_PREFIX, suffix=\".grg\", delete=False\n    )\n    temporary_file.write(george_script)\n    temporary_file.close()\n    temp_file_path = temporary_file.name.replace(\"\\\\\", \"/\")\n    self.execute_george(\"tv_runscript {}\".format(temp_file_path))\n    os.remove(temp_file_path)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.SenderTVPaintCommands","title":"<code>SenderTVPaintCommands</code>","text":"<p>               Bases: <code>TVPaintCommands</code></p> <p>Sender implementation of TVPaint Commands.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class SenderTVPaintCommands(TVPaintCommands):\n    \"\"\"Sender implementation of TVPaint Commands.\"\"\"\n    def _prepare_workfile(self, workfile):\n        \"\"\"Remove job queue root from workfile path.\n\n        It is expected that worker will add it's root before passed workfile.\n        \"\"\"\n        new_workfile = workfile.replace(\"\\\\\", \"/\")\n        job_queue_root = self.job_queue_root().replace(\"\\\\\", \"/\")\n        if job_queue_root not in new_workfile:\n            raise ValueError((\n                \"Workfile is not located in JobQueue root.\"\n                \" Workfile path: \\\"{}\\\". JobQueue root: \\\"{}\\\"\"\n            ).format(workfile, job_queue_root))\n        return new_workfile.replace(job_queue_root, \"\")\n\n    def commands_data(self):\n        \"\"\"Commands data to be able recreate them.\"\"\"\n        return [\n            command.command_data()\n            for command in self._commands\n        ]\n\n    def to_job_data(self):\n        \"\"\"Convert commands to job data before sending to workers server.\"\"\"\n        return {\n            \"workfile\": self._workfile,\n            \"function\": \"commands\",\n            \"commands\": self.commands_data()\n        }\n\n    def set_result(self, result):\n        commands_by_id = {\n            command.id: command\n            for command in self._commands\n        }\n\n        for item in result:\n            command = commands_by_id[item[\"id\"]]\n            command.set_result(item[\"result\"])\n            command.set_done()\n\n    def _send_job(self):\n        \"\"\"Send job to a workers server.\"\"\"\n        # Send job data to job queue server\n        job_data = self.to_job_data()\n        self.log.debug(\"Sending job to JobQueue server.\\n{}\".format(\n            json.dumps(job_data, indent=4)\n        ))\n        job_id = self._job_queue_module.send_job(\"tvpaint\", job_data)\n        self.log.info((\n            \"Job sent to JobQueue server and got id \\\"{}\\\".\"\n            \" Waiting for finishing the job.\"\n        ).format(job_id))\n\n        return job_id\n\n    def send_job_and_wait(self):\n        \"\"\"Send job to workers server and wait for response.\n\n        Result of job is stored into the object.\n\n        Raises:\n            JobFailed: When job was finished but not successfully.\n        \"\"\"\n        job_id = self._send_job()\n        while True:\n            job_status = self._job_queue_module.get_job_status(job_id)\n            if job_status[\"done\"]:\n                break\n            time.sleep(1)\n\n        # Check if job state is done\n        if job_status[\"state\"] != \"done\":\n            raise JobFailed(job_status)\n\n        self.set_result(job_status[\"result\"])\n\n        self.log.debug(\"Job is done and result is stored.\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.SenderTVPaintCommands.commands_data","title":"<code>commands_data()</code>","text":"<p>Commands data to be able recreate them.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def commands_data(self):\n    \"\"\"Commands data to be able recreate them.\"\"\"\n    return [\n        command.command_data()\n        for command in self._commands\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.SenderTVPaintCommands.send_job_and_wait","title":"<code>send_job_and_wait()</code>","text":"<p>Send job to workers server and wait for response.</p> <p>Result of job is stored into the object.</p> <p>Raises:</p> Type Description <code>JobFailed</code> <p>When job was finished but not successfully.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def send_job_and_wait(self):\n    \"\"\"Send job to workers server and wait for response.\n\n    Result of job is stored into the object.\n\n    Raises:\n        JobFailed: When job was finished but not successfully.\n    \"\"\"\n    job_id = self._send_job()\n    while True:\n        job_status = self._job_queue_module.get_job_status(job_id)\n        if job_status[\"done\"]:\n            break\n        time.sleep(1)\n\n    # Check if job state is done\n    if job_status[\"state\"] != \"done\":\n        raise JobFailed(job_status)\n\n    self.set_result(job_status[\"result\"])\n\n    self.log.debug(\"Job is done and result is stored.\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/index.html#client.ayon_tvpaint.worker.SenderTVPaintCommands.to_job_data","title":"<code>to_job_data()</code>","text":"<p>Convert commands to job data before sending to workers server.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def to_job_data(self):\n    \"\"\"Convert commands to job data before sending to workers server.\"\"\"\n    return {\n        \"workfile\": self._workfile,\n        \"function\": \"commands\",\n        \"commands\": self.commands_data()\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker.html","title":"worker","text":""},{"location":"autoapi/client/ayon_tvpaint/worker/worker.html#client.ayon_tvpaint.worker.worker.TVPaintWorkerCommunicator","title":"<code>TVPaintWorkerCommunicator</code>","text":"<p>               Bases: <code>BaseCommunicator</code></p> <p>Modified commuicator which cares about processing jobs.</p> <p>Received jobs are send to TVPaint by parsing 'ProcessTVPaintCommands'.</p> Source code in <code>client/ayon_tvpaint/worker/worker.py</code> <pre><code>class TVPaintWorkerCommunicator(BaseCommunicator):\n    \"\"\"Modified commuicator which cares about processing jobs.\n\n    Received jobs are send to TVPaint by parsing 'ProcessTVPaintCommands'.\n    \"\"\"\n    def __init__(self, server_url):\n        super().__init__()\n\n        self.return_code = 1\n        self._server_url = server_url\n        self._worker_connection = None\n\n    def _start_webserver(self):\n        \"\"\"Create connection to workers server before TVPaint server.\"\"\"\n        loop = self.websocket_server.loop\n        self._worker_connection = WorkerJobsConnection(\n            self._server_url, \"tvpaint\", loop\n        )\n        asyncio.ensure_future(\n            self._worker_connection.main_loop(register_worker=False),\n            loop=loop\n        )\n\n        super()._start_webserver()\n\n    def _open_init_file(self):\n        \"\"\"Open init TVPaint file.\n\n        File triggers dialog missing path to audio file which must be closed\n        once and is ignored for rest of running process.\n        \"\"\"\n        current_dir = os.path.dirname(os.path.abspath(__file__))\n        init_filepath = os.path.join(current_dir, \"init_file.tvpp\")\n        with tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=\"a_tvp_\", suffix=\".tvpp\"\n        ) as tmp_file:\n            tmp_filepath = tmp_file.name.replace(\"\\\\\", \"/\")\n\n        shutil.copy(init_filepath, tmp_filepath)\n        george_script = \"tv_LoadProject '\\\"'\\\"{}\\\"'\\\"'\".format(tmp_filepath)\n        self.execute_george_through_file(george_script)\n        self.execute_george(\"tv_projectclose\")\n        os.remove(tmp_filepath)\n\n    def _on_client_connect(self, *args, **kwargs):\n        super()._on_client_connect(*args, **kwargs)\n        self._open_init_file()\n        # Register as \"ready to work\" worker\n        self._worker_connection.register_as_worker()\n\n    def stop(self):\n        \"\"\"Stop worker connection and TVPaint server.\"\"\"\n        self._worker_connection.stop()\n        self.return_code = 0\n        super().stop()\n\n    @property\n    def current_job(self):\n        \"\"\"Retrieve job which should be processed.\"\"\"\n        if self._worker_connection:\n            return self._worker_connection.current_job\n        return None\n\n    def _check_process(self):\n        if self.process is None:\n            return True\n\n        if self.process.poll() is not None:\n            asyncio.ensure_future(\n                self._worker_connection.disconnect(),\n                loop=self.websocket_server.loop\n            )\n            self._exit()\n            return False\n        return True\n\n    def _process_job(self):\n        job = self.current_job\n        if job is None:\n            return\n\n        # Prepare variables used for sendig\n        success = False\n        message = \"Unknown function\"\n        data = None\n        job_data = job[\"data\"]\n        workfile = job_data[\"workfile\"]\n        # Currently can process only \"commands\" function\n        if job_data.get(\"function\") == \"commands\":\n            try:\n                commands = ProcessTVPaintCommands(\n                    workfile, job_data[\"commands\"], self\n                )\n                commands.execute()\n                data = commands.response_data()\n                success = True\n                message = \"Executed\"\n\n            except Exception as exc:\n                message = \"Error on worker: {}\".format(str(exc))\n\n        self._worker_connection.finish_job(success, message, data)\n\n    def main_loop(self):\n        \"\"\"Main loop where jobs are processed.\n\n        Server is stopped by killing this process or TVPaint process.\n        \"\"\"\n        while self.server_is_running:\n            if self._check_process():\n                self._process_job()\n            time.sleep(1)\n\n        return self.return_code\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker.html#client.ayon_tvpaint.worker.worker.TVPaintWorkerCommunicator.current_job","title":"<code>current_job</code>  <code>property</code>","text":"<p>Retrieve job which should be processed.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker.html#client.ayon_tvpaint.worker.worker.TVPaintWorkerCommunicator.main_loop","title":"<code>main_loop()</code>","text":"<p>Main loop where jobs are processed.</p> <p>Server is stopped by killing this process or TVPaint process.</p> Source code in <code>client/ayon_tvpaint/worker/worker.py</code> <pre><code>def main_loop(self):\n    \"\"\"Main loop where jobs are processed.\n\n    Server is stopped by killing this process or TVPaint process.\n    \"\"\"\n    while self.server_is_running:\n        if self._check_process():\n            self._process_job()\n        time.sleep(1)\n\n    return self.return_code\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker.html#client.ayon_tvpaint.worker.worker.TVPaintWorkerCommunicator.stop","title":"<code>stop()</code>","text":"<p>Stop worker connection and TVPaint server.</p> Source code in <code>client/ayon_tvpaint/worker/worker.py</code> <pre><code>def stop(self):\n    \"\"\"Stop worker connection and TVPaint server.\"\"\"\n    self._worker_connection.stop()\n    self.return_code = 0\n    super().stop()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html","title":"worker_job","text":""},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand","title":"<code>BaseCommand</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract TVPaint command which can be executed through worker.</p> <p>Each command must have unique name and implemented 'execute' and 'from_existing' methods.</p> <p>Command also have id which is created on command creation.</p> <p>The idea is that command is just a data container on sender side send through server to a worker where is replicated one by one, executed and result sent back to sender through server.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class BaseCommand(ABC):\n    \"\"\"Abstract TVPaint command which can be executed through worker.\n\n    Each command must have unique name and implemented 'execute' and\n    'from_existing' methods.\n\n    Command also have id which is created on command creation.\n\n    The idea is that command is just a data container on sender side send\n    through server to a worker where is replicated one by one, executed and\n    result sent back to sender through server.\n    \"\"\"\n    @property\n    @abstractmethod\n    def name(self):\n        \"\"\"Command name (must be unique).\"\"\"\n        pass\n\n    def __init__(self, data=None):\n        if data is None:\n            data = {}\n        else:\n            data = copy.deepcopy(data)\n\n        # Use 'id' from data when replicating on process side\n        command_id = data.get(\"id\")\n        if command_id is None:\n            command_id = str(uuid4())\n        data[\"id\"] = command_id\n        data[\"command\"] = self.name\n\n        self._parent = None\n        self._result = None\n        self._command_data = data\n        self._done = False\n\n    def job_queue_root(self):\n        \"\"\"Access to job queue root.\n\n        Job queue root is shared access point to files shared across senders\n        and workers.\n        \"\"\"\n        if self._parent is None:\n            return None\n        return self._parent.job_queue_root()\n\n    def set_parent(self, parent):\n        self._parent = parent\n\n    @property\n    def id(self):\n        \"\"\"Command id.\"\"\"\n        return self._command_data[\"id\"]\n\n    @property\n    def parent(self):\n        \"\"\"Parent of command expected type of 'TVPaintCommands'.\"\"\"\n        return self._parent\n\n    @property\n    def communicator(self):\n        \"\"\"TVPaint communicator.\n\n        Available only on worker side.\n        \"\"\"\n        return self._parent.communicator\n\n    @property\n    def done(self):\n        \"\"\"Is command done.\"\"\"\n        return self._done\n\n    def set_done(self):\n        \"\"\"Change state of done.\"\"\"\n        self._done = True\n\n    def set_result(self, result):\n        \"\"\"Set result of executed command.\"\"\"\n        self._result = result\n\n    def result(self):\n        \"\"\"Result of command.\"\"\"\n        return copy.deepcopy(self._result)\n\n    def response_data(self):\n        \"\"\"Data send as response to sender.\"\"\"\n        return {\n            \"id\": self.id,\n            \"result\": self._result,\n            \"done\": self._done\n        }\n\n    def command_data(self):\n        \"\"\"Raw command data.\"\"\"\n        return copy.deepcopy(self._command_data)\n\n    @abstractmethod\n    def execute(self):\n        \"\"\"Execute command on worker side.\"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def from_existing(cls, data):\n        \"\"\"Recreate object based on passed data.\"\"\"\n        pass\n\n    def execute_george(self, george_script):\n        \"\"\"Execute george script in TVPaint.\"\"\"\n        return self.parent.execute_george(george_script)\n\n    def execute_george_through_file(self, george_script):\n        \"\"\"Execute george script through temp file in TVPaint.\"\"\"\n        return self.parent.execute_george_through_file(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.communicator","title":"<code>communicator</code>  <code>property</code>","text":"<p>TVPaint communicator.</p> <p>Available only on worker side.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.done","title":"<code>done</code>  <code>property</code>","text":"<p>Is command done.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.id","title":"<code>id</code>  <code>property</code>","text":"<p>Command id.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.name","title":"<code>name</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Command name (must be unique).</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.parent","title":"<code>parent</code>  <code>property</code>","text":"<p>Parent of command expected type of 'TVPaintCommands'.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.command_data","title":"<code>command_data()</code>","text":"<p>Raw command data.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def command_data(self):\n    \"\"\"Raw command data.\"\"\"\n    return copy.deepcopy(self._command_data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.execute","title":"<code>execute()</code>  <code>abstractmethod</code>","text":"<p>Execute command on worker side.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>@abstractmethod\ndef execute(self):\n    \"\"\"Execute command on worker side.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.execute_george","title":"<code>execute_george(george_script)</code>","text":"<p>Execute george script in TVPaint.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def execute_george(self, george_script):\n    \"\"\"Execute george script in TVPaint.\"\"\"\n    return self.parent.execute_george(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.execute_george_through_file","title":"<code>execute_george_through_file(george_script)</code>","text":"<p>Execute george script through temp file in TVPaint.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def execute_george_through_file(self, george_script):\n    \"\"\"Execute george script through temp file in TVPaint.\"\"\"\n    return self.parent.execute_george_through_file(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.from_existing","title":"<code>from_existing(data)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Recreate object based on passed data.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_existing(cls, data):\n    \"\"\"Recreate object based on passed data.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.job_queue_root","title":"<code>job_queue_root()</code>","text":"<p>Access to job queue root.</p> <p>Job queue root is shared access point to files shared across senders and workers.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def job_queue_root(self):\n    \"\"\"Access to job queue root.\n\n    Job queue root is shared access point to files shared across senders\n    and workers.\n    \"\"\"\n    if self._parent is None:\n        return None\n    return self._parent.job_queue_root()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.response_data","title":"<code>response_data()</code>","text":"<p>Data send as response to sender.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def response_data(self):\n    \"\"\"Data send as response to sender.\"\"\"\n    return {\n        \"id\": self.id,\n        \"result\": self._result,\n        \"done\": self._done\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.result","title":"<code>result()</code>","text":"<p>Result of command.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def result(self):\n    \"\"\"Result of command.\"\"\"\n    return copy.deepcopy(self._result)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.set_done","title":"<code>set_done()</code>","text":"<p>Change state of done.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def set_done(self):\n    \"\"\"Change state of done.\"\"\"\n    self._done = True\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.BaseCommand.set_result","title":"<code>set_result(result)</code>","text":"<p>Set result of executed command.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def set_result(self, result):\n    \"\"\"Set result of executed command.\"\"\"\n    self._result = result\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.CollectSceneData","title":"<code>CollectSceneData</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Helper command which will collect all useful info about workfile.</p> <p>Result is dictionary with all layers data, exposure frames by layer ids pre/post behavior of layers by their ids, group information and scene data.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class CollectSceneData(BaseCommand):\n    \"\"\"Helper command which will collect all useful info about workfile.\n\n    Result is dictionary with all layers data, exposure frames by layer ids\n    pre/post behavior of layers by their ids, group information and scene data.\n    \"\"\"\n    name = \"collect_scene_data\"\n\n    def execute(self):\n        from ayon_tvpaint.api.lib import (\n            get_layers_data,\n            get_groups_data,\n            get_layers_pre_post_behavior,\n            get_layers_exposure_frames,\n            get_scene_data\n        )\n\n        groups_data = get_groups_data(communicator=self.communicator)\n        layers_data = get_layers_data(communicator=self.communicator)\n        layer_ids = [\n            layer_data[\"layer_id\"]\n            for layer_data in layers_data\n        ]\n        pre_post_beh_by_layer_id = get_layers_pre_post_behavior(\n            layer_ids, communicator=self.communicator\n        )\n        exposure_frames_by_layer_id = get_layers_exposure_frames(\n            layer_ids, layers_data, communicator=self.communicator\n        )\n\n        self._result = {\n            \"layers_data\": layers_data,\n            \"exposure_frames_by_layer_id\": exposure_frames_by_layer_id,\n            \"pre_post_beh_by_layer_id\": pre_post_beh_by_layer_id,\n            \"groups_data\": groups_data,\n            \"scene_data\": get_scene_data(self.communicator)\n        }\n\n    @classmethod\n    def from_existing(cls, data):\n        return cls(data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ExecuteGeorgeScript","title":"<code>ExecuteGeorgeScript</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Execute multiline george script in TVPaint.</p> <p>Parameters:</p> Name Type Description Default <code>script_lines(list)</code> <p>Lines that will be executed in george script through temp george file.</p> required <code>tmp_file_keys(list)</code> <p>List of formatting keys in george script that require replacement with path to a temp file where result will be stored. The content of file is stored to result by the key.</p> required <code>root_dir_key(str)</code> <p>Formatting key that will be replaced in george script with job queue root which can be different on worker side.</p> required <code>data(dict)</code> <p>Raw data about command.</p> required Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class ExecuteGeorgeScript(BaseCommand):\n    \"\"\"Execute multiline george script in TVPaint.\n\n    Args:\n        script_lines(list): Lines that will be executed in george script\n            through temp george file.\n        tmp_file_keys(list): List of formatting keys in george script that\n            require replacement with path to a temp file where result will be\n            stored. The content of file is stored to result by the key.\n        root_dir_key(str): Formatting key that will be replaced in george\n            script with job queue root which can be different on worker side.\n        data(dict): Raw data about command.\n    \"\"\"\n    name = \"execute_george_through_file\"\n\n    def __init__(\n        self, script_lines, tmp_file_keys=None, root_dir_key=None, data=None\n    ):\n        data = data or {}\n        if not tmp_file_keys:\n            tmp_file_keys = data.get(\"tmp_file_keys\") or []\n\n        data[\"script_lines\"] = script_lines\n        data[\"tmp_file_keys\"] = tmp_file_keys\n        data[\"root_dir_key\"] = root_dir_key\n        self._script_lines = script_lines\n        self._tmp_file_keys = tmp_file_keys\n        self._root_dir_key = root_dir_key\n        super().__init__(data)\n\n    def execute(self):\n        filepath_by_key = {}\n        script = self._script_lines\n        if isinstance(script, list):\n            script = \"\\n\".join(script)\n\n        # Replace temporary files in george script\n        for key in self._tmp_file_keys:\n            output_file = tempfile.NamedTemporaryFile(\n                mode=\"w\", prefix=TMP_FILE_PREFIX, suffix=\".txt\", delete=False\n            )\n            output_file.close()\n            format_key = \"{\" + key + \"}\"\n            output_path = output_file.name.replace(\"\\\\\", \"/\")\n            script = script.replace(format_key, output_path)\n            filepath_by_key[key] = output_path\n\n        # Replace job queue root in script\n        if self._root_dir_key:\n            job_queue_root = self.job_queue_root()\n            format_key = \"{\" + self._root_dir_key + \"}\"\n            script = script.replace(\n                format_key, job_queue_root.replace(\"\\\\\", \"/\")\n            )\n\n        # Execute the script\n        self.execute_george_through_file(script)\n\n        # Store result of temporary files\n        result = {}\n        for key, filepath in filepath_by_key.items():\n            with open(filepath, \"r\") as stream:\n                data = stream.read()\n            result[key] = data\n            os.remove(filepath)\n\n        self._result = result\n\n    @classmethod\n    def from_existing(cls, data):\n        \"\"\"Recreate the object from data.\"\"\"\n        script_lines = data.pop(\"script_lines\")\n        tmp_file_keys = data.pop(\"tmp_file_keys\", None)\n        root_dir_key = data.pop(\"root_dir_key\", None)\n        return cls(script_lines, tmp_file_keys, root_dir_key, data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ExecuteGeorgeScript.from_existing","title":"<code>from_existing(data)</code>  <code>classmethod</code>","text":"<p>Recreate the object from data.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>@classmethod\ndef from_existing(cls, data):\n    \"\"\"Recreate the object from data.\"\"\"\n    script_lines = data.pop(\"script_lines\")\n    tmp_file_keys = data.pop(\"tmp_file_keys\", None)\n    root_dir_key = data.pop(\"root_dir_key\", None)\n    return cls(script_lines, tmp_file_keys, root_dir_key, data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ExecuteSimpleGeorgeScript","title":"<code>ExecuteSimpleGeorgeScript</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Execute simple george script in TVPaint.</p> <p>Parameters:</p> Name Type Description Default <code>script(str)</code> <p>Script that will be executed.</p> required Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class ExecuteSimpleGeorgeScript(BaseCommand):\n    \"\"\"Execute simple george script in TVPaint.\n\n    Args:\n        script(str): Script that will be executed.\n    \"\"\"\n    name = \"execute_george_simple\"\n\n    def __init__(self, script, data=None):\n        data = data or {}\n        data[\"script\"] = script\n        self._script = script\n        super().__init__(data)\n\n    def execute(self):\n        self._result = self.execute_george(self._script)\n\n    @classmethod\n    def from_existing(cls, data):\n        script = data.pop(\"script\")\n        return cls(script, data)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.JobFailed","title":"<code>JobFailed</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when job was sent and finished unsuccessfully.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class JobFailed(Exception):\n    \"\"\"Raised when job was sent and finished unsuccessfully.\"\"\"\n    def __init__(self, job_status):\n        job_state = job_status[\"state\"]\n        job_message = job_status[\"message\"] or \"Unknown issue\"\n        error_msg = (\n            \"Job didn't finish properly.\"\n            \" Job state: \\\"{}\\\" | Job message: \\\"{}\\\"\"\n        ).format(job_state, job_message)\n\n        self.job_status = job_status\n\n        super().__init__(error_msg)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ProcessTVPaintCommands","title":"<code>ProcessTVPaintCommands</code>","text":"<p>               Bases: <code>TVPaintCommands</code></p> <p>Worker side of TVPaint Commands.</p> <p>It is expected this object is created only on worker's side from existing data loaded from job.</p> <p>Workfile path logic is based on 'SenderTVPaintCommands'.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class ProcessTVPaintCommands(TVPaintCommands):\n    \"\"\"Worker side of TVPaint Commands.\n\n    It is expected this object is created only on worker's side from existing\n    data loaded from job.\n\n    Workfile path logic is based on 'SenderTVPaintCommands'.\n    \"\"\"\n    def __init__(self, workfile, commands, communicator):\n        super(ProcessTVPaintCommands, self).__init__(workfile)\n\n        self._communicator = communicator\n\n        self.commands_from_data(commands)\n\n    def _prepare_workfile(self, workfile):\n        \"\"\"Preprend job queue root before passed workfile.\"\"\"\n        workfile = workfile.replace(\"\\\\\", \"/\")\n        job_queue_root = self.job_queue_root().replace(\"\\\\\", \"/\")\n        new_workfile = \"/\".join([job_queue_root, workfile])\n        while \"//\" in new_workfile:\n            new_workfile = new_workfile.replace(\"//\", \"/\")\n        return os.path.normpath(new_workfile)\n\n    @property\n    def communicator(self):\n        \"\"\"Access to TVPaint communicator.\"\"\"\n        return self._communicator\n\n    def commands_from_data(self, commands_data):\n        \"\"\"Recreate command from passed data.\"\"\"\n        for command_data in commands_data:\n            command_name = command_data[\"command\"]\n\n            klass = self.classes_by_name[command_name]\n            command = klass.from_existing(command_data)\n            self.add_command(command)\n\n    def execute_george(self, george_script):\n        \"\"\"Helper method to execute george script.\"\"\"\n        return self.communicator.execute_george(george_script)\n\n    def execute_george_through_file(self, george_script):\n        \"\"\"Helper method to execute george script through temp file.\"\"\"\n        temporary_file = tempfile.NamedTemporaryFile(\n            mode=\"w\", prefix=TMP_FILE_PREFIX, suffix=\".grg\", delete=False\n        )\n        temporary_file.write(george_script)\n        temporary_file.close()\n        temp_file_path = temporary_file.name.replace(\"\\\\\", \"/\")\n        self.execute_george(\"tv_runscript {}\".format(temp_file_path))\n        os.remove(temp_file_path)\n\n    def _open_workfile(self):\n        \"\"\"Open workfile in TVPaint.\"\"\"\n        workfile = self._workfile\n        print(\"Opening workfile {}\".format(workfile))\n        george_script = \"tv_LoadProject '\\\"'\\\"{}\\\"'\\\"'\".format(workfile)\n        self.execute_george_through_file(george_script)\n\n    def _close_workfile(self):\n        \"\"\"Close workfile in TVPaint.\"\"\"\n        print(\"Closing workfile\")\n        self.execute_george_through_file(\"tv_projectclose\")\n\n    def execute(self):\n        \"\"\"Execute commands.\"\"\"\n        # First open the workfile\n        self._open_workfile()\n        # Execute commands one by one\n        # TODO maybe stop processing when command fails?\n        print(\"Commands execution started ({})\".format(len(self._commands)))\n        for command in self._commands:\n            command.execute()\n            command.set_done()\n        # Finally close workfile\n        self._close_workfile()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ProcessTVPaintCommands.communicator","title":"<code>communicator</code>  <code>property</code>","text":"<p>Access to TVPaint communicator.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ProcessTVPaintCommands.commands_from_data","title":"<code>commands_from_data(commands_data)</code>","text":"<p>Recreate command from passed data.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def commands_from_data(self, commands_data):\n    \"\"\"Recreate command from passed data.\"\"\"\n    for command_data in commands_data:\n        command_name = command_data[\"command\"]\n\n        klass = self.classes_by_name[command_name]\n        command = klass.from_existing(command_data)\n        self.add_command(command)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ProcessTVPaintCommands.execute","title":"<code>execute()</code>","text":"<p>Execute commands.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def execute(self):\n    \"\"\"Execute commands.\"\"\"\n    # First open the workfile\n    self._open_workfile()\n    # Execute commands one by one\n    # TODO maybe stop processing when command fails?\n    print(\"Commands execution started ({})\".format(len(self._commands)))\n    for command in self._commands:\n        command.execute()\n        command.set_done()\n    # Finally close workfile\n    self._close_workfile()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ProcessTVPaintCommands.execute_george","title":"<code>execute_george(george_script)</code>","text":"<p>Helper method to execute george script.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def execute_george(self, george_script):\n    \"\"\"Helper method to execute george script.\"\"\"\n    return self.communicator.execute_george(george_script)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.ProcessTVPaintCommands.execute_george_through_file","title":"<code>execute_george_through_file(george_script)</code>","text":"<p>Helper method to execute george script through temp file.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def execute_george_through_file(self, george_script):\n    \"\"\"Helper method to execute george script through temp file.\"\"\"\n    temporary_file = tempfile.NamedTemporaryFile(\n        mode=\"w\", prefix=TMP_FILE_PREFIX, suffix=\".grg\", delete=False\n    )\n    temporary_file.write(george_script)\n    temporary_file.close()\n    temp_file_path = temporary_file.name.replace(\"\\\\\", \"/\")\n    self.execute_george(\"tv_runscript {}\".format(temp_file_path))\n    os.remove(temp_file_path)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.SenderTVPaintCommands","title":"<code>SenderTVPaintCommands</code>","text":"<p>               Bases: <code>TVPaintCommands</code></p> <p>Sender implementation of TVPaint Commands.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class SenderTVPaintCommands(TVPaintCommands):\n    \"\"\"Sender implementation of TVPaint Commands.\"\"\"\n    def _prepare_workfile(self, workfile):\n        \"\"\"Remove job queue root from workfile path.\n\n        It is expected that worker will add it's root before passed workfile.\n        \"\"\"\n        new_workfile = workfile.replace(\"\\\\\", \"/\")\n        job_queue_root = self.job_queue_root().replace(\"\\\\\", \"/\")\n        if job_queue_root not in new_workfile:\n            raise ValueError((\n                \"Workfile is not located in JobQueue root.\"\n                \" Workfile path: \\\"{}\\\". JobQueue root: \\\"{}\\\"\"\n            ).format(workfile, job_queue_root))\n        return new_workfile.replace(job_queue_root, \"\")\n\n    def commands_data(self):\n        \"\"\"Commands data to be able recreate them.\"\"\"\n        return [\n            command.command_data()\n            for command in self._commands\n        ]\n\n    def to_job_data(self):\n        \"\"\"Convert commands to job data before sending to workers server.\"\"\"\n        return {\n            \"workfile\": self._workfile,\n            \"function\": \"commands\",\n            \"commands\": self.commands_data()\n        }\n\n    def set_result(self, result):\n        commands_by_id = {\n            command.id: command\n            for command in self._commands\n        }\n\n        for item in result:\n            command = commands_by_id[item[\"id\"]]\n            command.set_result(item[\"result\"])\n            command.set_done()\n\n    def _send_job(self):\n        \"\"\"Send job to a workers server.\"\"\"\n        # Send job data to job queue server\n        job_data = self.to_job_data()\n        self.log.debug(\"Sending job to JobQueue server.\\n{}\".format(\n            json.dumps(job_data, indent=4)\n        ))\n        job_id = self._job_queue_module.send_job(\"tvpaint\", job_data)\n        self.log.info((\n            \"Job sent to JobQueue server and got id \\\"{}\\\".\"\n            \" Waiting for finishing the job.\"\n        ).format(job_id))\n\n        return job_id\n\n    def send_job_and_wait(self):\n        \"\"\"Send job to workers server and wait for response.\n\n        Result of job is stored into the object.\n\n        Raises:\n            JobFailed: When job was finished but not successfully.\n        \"\"\"\n        job_id = self._send_job()\n        while True:\n            job_status = self._job_queue_module.get_job_status(job_id)\n            if job_status[\"done\"]:\n                break\n            time.sleep(1)\n\n        # Check if job state is done\n        if job_status[\"state\"] != \"done\":\n            raise JobFailed(job_status)\n\n        self.set_result(job_status[\"result\"])\n\n        self.log.debug(\"Job is done and result is stored.\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.SenderTVPaintCommands.commands_data","title":"<code>commands_data()</code>","text":"<p>Commands data to be able recreate them.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def commands_data(self):\n    \"\"\"Commands data to be able recreate them.\"\"\"\n    return [\n        command.command_data()\n        for command in self._commands\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.SenderTVPaintCommands.send_job_and_wait","title":"<code>send_job_and_wait()</code>","text":"<p>Send job to workers server and wait for response.</p> <p>Result of job is stored into the object.</p> <p>Raises:</p> Type Description <code>JobFailed</code> <p>When job was finished but not successfully.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def send_job_and_wait(self):\n    \"\"\"Send job to workers server and wait for response.\n\n    Result of job is stored into the object.\n\n    Raises:\n        JobFailed: When job was finished but not successfully.\n    \"\"\"\n    job_id = self._send_job()\n    while True:\n        job_status = self._job_queue_module.get_job_status(job_id)\n        if job_status[\"done\"]:\n            break\n        time.sleep(1)\n\n    # Check if job state is done\n    if job_status[\"state\"] != \"done\":\n        raise JobFailed(job_status)\n\n    self.set_result(job_status[\"result\"])\n\n    self.log.debug(\"Job is done and result is stored.\")\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.SenderTVPaintCommands.to_job_data","title":"<code>to_job_data()</code>","text":"<p>Convert commands to job data before sending to workers server.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def to_job_data(self):\n    \"\"\"Convert commands to job data before sending to workers server.\"\"\"\n    return {\n        \"workfile\": self._workfile,\n        \"function\": \"commands\",\n        \"commands\": self.commands_data()\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.TVPaintCommands","title":"<code>TVPaintCommands</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Wrapper around TVPaint commands to be able send multiple commands.</p> <p>Commands may send one or multiple commands at once. Also gives api access for commands info.</p> <p>Base for sender and receiver which are extending the logic for their purposes. One of differences is preparation of workfile path.</p> <p>Parameters:</p> Name Type Description Default <code>workfile(str)</code> <p>Path to workfile.</p> required <code>job_queue_module(JobQueueModule)</code> <p>Object of AYON module JobQueue.</p> required Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>class TVPaintCommands(ABC):\n    \"\"\"Wrapper around TVPaint commands to be able send multiple commands.\n\n    Commands may send one or multiple commands at once. Also gives api access\n    for commands info.\n\n    Base for sender and receiver which are extending the logic for their\n    purposes. One of differences is preparation of workfile path.\n\n    Args:\n        workfile(str): Path to workfile.\n        job_queue_module(JobQueueModule): Object of AYON module JobQueue.\n    \"\"\"\n    def __init__(self, workfile, job_queue_module=None):\n        self._log = None\n        self._commands = []\n        self._command_classes_by_name = None\n        if job_queue_module is None:\n            manager = AddonsManger()\n            job_queue_module = manager[\"job_queue\"]\n        self._job_queue_module = job_queue_module\n\n        self._workfile = self._prepare_workfile(workfile)\n\n    @abstractmethod\n    def _prepare_workfile(self, workfile):\n        \"\"\"Modification of workfile path on initialization to match platorm.\"\"\"\n        pass\n\n    def job_queue_root(self):\n        \"\"\"Job queue root for current platform using current settings.\"\"\"\n        return self._job_queue_module.get_jobs_root_from_settings()\n\n    @property\n    def log(self):\n        \"\"\"Access to logger object.\"\"\"\n        if self._log is None:\n            self._log = Logger.get_logger(self.__class__.__name__)\n        return self._log\n\n    @property\n    def classes_by_name(self):\n        \"\"\"Prepare commands classes for validation and recreation of commands.\n\n        It is expected that all commands are defined in this python file so\n        we're looking for all implementation of BaseCommand in globals.\n        \"\"\"\n        if self._command_classes_by_name is None:\n            command_classes_by_name = {}\n            for attr in globals().values():\n                if (\n                    not inspect.isclass(attr)\n                    or not issubclass(attr, BaseCommand)\n                    or attr is BaseCommand\n                ):\n                    continue\n\n                if inspect.isabstract(attr):\n                    self.log.debug(\n                        \"Skipping abstract class {}\".format(attr.__name__)\n                    )\n                command_classes_by_name[attr.name] = attr\n            self._command_classes_by_name = command_classes_by_name\n\n        return self._command_classes_by_name\n\n    def add_command(self, command):\n        \"\"\"Add command to process.\"\"\"\n        command.set_parent(self)\n        self._commands.append(command)\n\n    def result(self):\n        \"\"\"Result of commands in list in which they were processed.\"\"\"\n        return [\n            command.result()\n            for command in self._commands\n        ]\n\n    def response_data(self):\n        \"\"\"Data which should be send from worker.\"\"\"\n        return [\n            command.response_data()\n            for command in self._commands\n        ]\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.TVPaintCommands.classes_by_name","title":"<code>classes_by_name</code>  <code>property</code>","text":"<p>Prepare commands classes for validation and recreation of commands.</p> <p>It is expected that all commands are defined in this python file so we're looking for all implementation of BaseCommand in globals.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.TVPaintCommands.log","title":"<code>log</code>  <code>property</code>","text":"<p>Access to logger object.</p>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.TVPaintCommands.add_command","title":"<code>add_command(command)</code>","text":"<p>Add command to process.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def add_command(self, command):\n    \"\"\"Add command to process.\"\"\"\n    command.set_parent(self)\n    self._commands.append(command)\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.TVPaintCommands.job_queue_root","title":"<code>job_queue_root()</code>","text":"<p>Job queue root for current platform using current settings.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def job_queue_root(self):\n    \"\"\"Job queue root for current platform using current settings.\"\"\"\n    return self._job_queue_module.get_jobs_root_from_settings()\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.TVPaintCommands.response_data","title":"<code>response_data()</code>","text":"<p>Data which should be send from worker.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def response_data(self):\n    \"\"\"Data which should be send from worker.\"\"\"\n    return [\n        command.response_data()\n        for command in self._commands\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_tvpaint/worker/worker_job.html#client.ayon_tvpaint.worker.worker_job.TVPaintCommands.result","title":"<code>result()</code>","text":"<p>Result of commands in list in which they were processed.</p> Source code in <code>client/ayon_tvpaint/worker/worker_job.py</code> <pre><code>def result(self):\n    \"\"\"Result of commands in list in which they were processed.\"\"\"\n    return [\n        command.result()\n        for command in self._commands\n    ]\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/settings/index.html","title":"settings","text":""},{"location":"autoapi/server/settings/create_plugins.html","title":"create_plugins","text":""},{"location":"autoapi/server/settings/create_plugins.html#server.settings.create_plugins.AutoDetectCreateRenderModel","title":"<code>AutoDetectCreateRenderModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>The creator tries to auto-detect Render Layers and Render Passes in scene.</p> <p>For Render Layers is used group name as a variant and for Render Passes is used TVPaint layer name.</p> <p>Group names can be renamed by their used order in scene. The renaming template where can be used '{group_index}' formatting key which is filled by \"used position index of group\". - Template: 'L{group_index}' - Group offset: '10' - Group padding: '3'</p> <p>Would create group names \"L010\", \"L020\", ...</p> Source code in <code>server/settings/create_plugins.py</code> <pre><code>class AutoDetectCreateRenderModel(BaseSettingsModel):\n    \"\"\"The creator tries to auto-detect Render Layers and Render Passes in scene.\n\n    For Render Layers is used group name as a variant and for Render Passes is\n    used TVPaint layer name.\n\n    Group names can be renamed by their used order in scene. The renaming\n    template where can be used '{group_index}' formatting key which is\n    filled by \"used position index of group\".\n    - Template: 'L{group_index}'\n    - Group offset: '10'\n    - Group padding: '3'\n\n    Would create group names \"L010\", \"L020\", ...\n    \"\"\"\n\n    enabled: bool = SettingsField(True)\n    allow_group_rename: bool = SettingsField(title=\"Allow group rename\")\n    group_name_template: str = SettingsField(title=\"Group name template\")\n    group_idx_offset: int = SettingsField(\n        1, title=\"Group index Offset\", ge=1\n    )\n    group_idx_padding: int = SettingsField(\n        4, title=\"Group index Padding\", ge=1\n    )\n</code></pre>"},{"location":"autoapi/server/settings/filters.html","title":"filters","text":""},{"location":"autoapi/server/settings/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings/main.html","title":"main","text":""},{"location":"autoapi/server/settings/publish_plugins.html","title":"publish_plugins","text":""},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ExtractConvertToEXRModel","title":"<code>ExtractConvertToEXRModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>WARNING: This plugin does not work on MacOS (using OIIO tool).</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ExtractConvertToEXRModel(BaseSettingsModel):\n    \"\"\"WARNING: This plugin does not work on MacOS (using OIIO tool).\"\"\"\n    enabled: bool = False\n    replace_pngs: bool = True\n\n    exr_compression: str = SettingsField(\n        \"ZIP\",\n        enum_resolver=compression_enum,\n        title=\"EXR Compression\"\n    )\n</code></pre>"},{"location":"autoapi/server/settings/publish_plugins.html#server.settings.publish_plugins.ExtractSequenceModel","title":"<code>ExtractSequenceModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Review BG color is used for whole scene review and for thumbnails.</p> Source code in <code>server/settings/publish_plugins.py</code> <pre><code>class ExtractSequenceModel(BaseSettingsModel):\n    \"\"\"Review BG color is used for whole scene review and for thumbnails.\"\"\"\n    review_bg: ColorRGBA_uint8 = SettingsField(\n        (255, 255, 255, 1.0),\n        title=\"Review BG color\")\n</code></pre>"},{"location":"autoapi/server/settings/workfile_builder.html","title":"workfile_builder","text":""}]}